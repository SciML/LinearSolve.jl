<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear System Solvers · LinearSolve.jl</title><meta name="title" content="Linear System Solvers · LinearSolve.jl"/><meta property="og:title" content="Linear System Solvers · LinearSolve.jl"/><meta property="twitter:title" content="Linear System Solvers · LinearSolve.jl"/><meta name="description" content="Documentation for LinearSolve.jl."/><meta property="og:description" content="Documentation for LinearSolve.jl."/><meta property="twitter:description" content="Documentation for LinearSolve.jl."/><meta property="og:url" content="https://docs.sciml.ai/LinearSolve/stable/solvers/solvers/"/><meta property="twitter:url" content="https://docs.sciml.ai/LinearSolve/stable/solvers/solvers/"/><link rel="canonical" href="https://docs.sciml.ai/LinearSolve/stable/solvers/solvers/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="LinearSolve.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LinearSolve.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">LinearSolve.jl: High-Performance Unified Linear Solvers</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/linear/">Solving Linear Systems in Julia</a></li><li><a class="tocitem" href="../../tutorials/caching_interface/">Linear Solve with Caching Interface</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/LinearProblem/">Linear Problems</a></li><li><a class="tocitem" href="../../basics/common_solver_opts/">Common Solver Options (Keyword Arguments for Solve)</a></li><li><a class="tocitem" href="../../basics/OperatorAssumptions/">Linear Solve Operator Assumptions</a></li><li><a class="tocitem" href="../../basics/Preconditioners/">Preconditioners</a></li><li><a class="tocitem" href="../../basics/FAQ/">Frequently Asked Questions</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li class="is-active"><a class="tocitem" href>Linear System Solvers</a><ul class="internal"><li><a class="tocitem" href="#Recommended-Methods"><span>Recommended Methods</span></a></li><li><a class="tocitem" href="#Full-List-of-Methods"><span>Full List of Methods</span></a></li></ul></li></ul></li><li><span class="tocitem">Advanced</span><ul><li><a class="tocitem" href="../../advanced/developing/">Developing New Linear Solvers</a></li><li><a class="tocitem" href="../../advanced/custom/">Passing in a Custom Linear Solver</a></li></ul></li><li><a class="tocitem" href="../../release_notes/">Release Notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solvers</a></li><li class="is-active"><a href>Linear System Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linear System Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/LinearSolve.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/LinearSolve.jl/blob/main/docs/src/solvers/solvers.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="linearsystemsolvers"><a class="docs-heading-anchor" href="#linearsystemsolvers">Linear System Solvers</a><a id="linearsystemsolvers-1"></a><a class="docs-heading-anchor-permalink" href="#linearsystemsolvers" title="Permalink"></a></h1><p><code>solve(prob::LinearProblem,alg;kwargs)</code></p><p>Solves for <span>$Au=b$</span> in the problem defined by <code>prob</code> using the algorithm <code>alg</code>. If no algorithm is given, a default algorithm will be chosen.</p><h2 id="Recommended-Methods"><a class="docs-heading-anchor" href="#Recommended-Methods">Recommended Methods</a><a id="Recommended-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Recommended-Methods" title="Permalink"></a></h2><h3 id="Dense-Matrices"><a class="docs-heading-anchor" href="#Dense-Matrices">Dense Matrices</a><a id="Dense-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Dense-Matrices" title="Permalink"></a></h3><p>The default algorithm <code>nothing</code> is good for picking an algorithm that will work, but one may need to change this to receive more performance or precision. If more precision is necessary, <code>QRFactorization()</code> and <code>SVDFactorization()</code> are the best choices, with SVD being the slowest but most precise.</p><p>For efficiency, <code>RFLUFactorization</code> is the fastest for dense LU-factorizations until around 150x150 matrices, though this can be dependent on the exact details of the hardware. After this point, <code>MKLLUFactorization</code> is usually faster on most hardware. Note that on Mac computers that <code>AppleAccelerateLUFactorization</code> is generally always the fastest. <code>LUFactorization</code> will use your base system BLAS which can be fast or slow depending on the hardware configuration. <code>SimpleLUFactorization</code> will be fast only on very small matrices but can cut down on compile times.</p><p>For very large dense factorizations, offloading to the GPU can be preferred. Metal.jl can be used on Mac hardware to offload, and has a cutoff point of being faster at around size 20,000 x 20,000 matrices (and only supports Float32). <code>CudaOffloadFactorization</code> can be more efficient at a much smaller cutoff, possibly around size 1,000 x 1,000 matrices, though this is highly dependent on the chosen GPU hardware. <code>CudaOffloadFactorization</code> requires a CUDA-compatible NVIDIA GPU. CUDA offload supports Float64 but most consumer GPU hardware will be much faster on Float32 (many are &gt;32x faster for Float32 operations than Float64 operations) and thus for most hardware this is only recommended for Float32 matrices.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Performance details for dense LU-factorizations can be highly dependent on the hardware configuration. For details see <a href="https://github.com/SciML/LinearSolve.jl/issues/357">this issue</a>. If one is looking to best optimize their system, we suggest running the performance tuning benchmark.</p></div></div><h3 id="Sparse-Matrices"><a class="docs-heading-anchor" href="#Sparse-Matrices">Sparse Matrices</a><a id="Sparse-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-Matrices" title="Permalink"></a></h3><p>For sparse LU-factorizations, <code>KLUFactorization</code> if there is less structure to the sparsity pattern and <code>UMFPACKFactorization</code> if there is more structure. Pardiso.jl&#39;s methods are also known to be very efficient sparse linear solvers.</p><p>While these sparse factorizations are based on implementations in other languages, and therefore constrained to standard number types (<code>Float64</code>,  <code>Float32</code> and their complex counterparts),  <code>SparspakFactorization</code> is able to handle general number types, e.g. defined by <code>ForwardDiff.jl</code>, <code>MultiFloats.jl</code>, or <code>IntervalArithmetics.jl</code>.</p><p>As sparse matrices get larger, iterative solvers tend to get more efficient than factorization methods if a lower tolerance of the solution is required.</p><p>Krylov.jl generally outperforms IterativeSolvers.jl and KrylovKit.jl, and is compatible with CPUs and GPUs, and thus is the generally preferred form for Krylov methods. The choice of Krylov method should be the one most constrained to the type of operator one has, for example if positive definite then <code>Krylov_CG()</code>, but if no good properties then use <code>Krylov_GMRES()</code>.</p><p>Finally, a user can pass a custom function for handling the linear solve using <code>LinearSolveFunction()</code> if existing solvers are not optimally suited for their application. The interface is detailed <a href="../../advanced/custom/#custom">here</a>.</p><h3 id="Lazy-SciMLOperators"><a class="docs-heading-anchor" href="#Lazy-SciMLOperators">Lazy SciMLOperators</a><a id="Lazy-SciMLOperators-1"></a><a class="docs-heading-anchor-permalink" href="#Lazy-SciMLOperators" title="Permalink"></a></h3><p>If the linear operator is given as a lazy non-concrete operator, such as a <code>FunctionOperator</code>, then using a Krylov method is preferred in order to not concretize the matrix. Krylov.jl generally outperforms IterativeSolvers.jl and KrylovKit.jl, and is compatible with CPUs and GPUs, and thus is the generally preferred form for Krylov methods. The choice of Krylov method should be the one most constrained to the type of operator one has, for example if positive definite then <code>Krylov_CG()</code>, but if no good properties then use <code>Krylov_GMRES()</code>.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>If your materialized operator is a uniform block diagonal matrix, then you can use <code>SimpleGMRES(; blocksize = &lt;known block size&gt;)</code> to further improve performance. This often shows up in Neural Networks where the Jacobian wrt the Inputs (almost always) is a Uniform Block Diagonal matrix of Block Size = size of the input divided by the batch size.</p></div></div><h2 id="Full-List-of-Methods"><a class="docs-heading-anchor" href="#Full-List-of-Methods">Full List of Methods</a><a id="Full-List-of-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Full-List-of-Methods" title="Permalink"></a></h2><h3 id="RecursiveFactorization.jl"><a class="docs-heading-anchor" href="#RecursiveFactorization.jl">RecursiveFactorization.jl</a><a id="RecursiveFactorization.jl-1"></a><a class="docs-heading-anchor-permalink" href="#RecursiveFactorization.jl" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.RFLUFactorization" href="#LinearSolve.RFLUFactorization"><code>LinearSolve.RFLUFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>RFLUFactorization()</code></p><p>A fast pure Julia LU-factorization implementation using RecursiveFactorization.jl. This is by far the fastest LU-factorization implementation, usually outperforming OpenBLAS and MKL for smaller matrices (&lt;500x500), but currently optimized only for Base <code>Array</code> with <code>Float32</code> or <code>Float64</code>. Additional optimization for complex matrices is in the works.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/factorization.jl#L928-L936">source</a></section></article><h3 id="Base.LinearAlgebra"><a class="docs-heading-anchor" href="#Base.LinearAlgebra">Base.LinearAlgebra</a><a id="Base.LinearAlgebra-1"></a><a class="docs-heading-anchor-permalink" href="#Base.LinearAlgebra" title="Permalink"></a></h3><p>These overloads tend to work for many array types, such as <code>CuArrays</code> for GPU-accelerated solving, using the overloads provided by the respective packages. Given that this can be customized per-package, details given below describe a subset of important arrays (<code>Matrix</code>, <code>SparseMatrixCSC</code>, <code>CuMatrix</code>, etc.)</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.LUFactorization" href="#LinearSolve.LUFactorization"><code>LinearSolve.LUFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>LUFactorization(pivot=LinearAlgebra.RowMaximum())</code></p><p>Julia&#39;s built in <code>lu</code>. Equivalent to calling <code>lu!(A)</code></p><ul><li>On dense matrices, this uses the current BLAS implementation of the user&#39;s computer,</li></ul><p>which by default is OpenBLAS but will use MKL if the user does <code>using MKL</code> in their system.</p><ul><li>On sparse matrices, this will use UMFPACK from SuiteSparse. Note that this will not</li></ul><p>cache the symbolic factorization.</p><ul><li>On CuMatrix, it will use a CUDA-accelerated LU from CuSolver.</li><li>On BandedMatrix and BlockBandedMatrix, it will use a banded LU.</li></ul><p><strong>Positional Arguments</strong></p><ul><li>pivot: The choice of pivoting. Defaults to <code>LinearAlgebra.RowMaximum()</code>. The other choice is <code>LinearAlgebra.NoPivot()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/factorization.jl#L28-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.GenericLUFactorization" href="#LinearSolve.GenericLUFactorization"><code>LinearSolve.GenericLUFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>GenericLUFactorization(pivot=LinearAlgebra.RowMaximum())</code></p><p>Julia&#39;s built in generic LU factorization. Equivalent to calling LinearAlgebra.generic_lufact!. Supports arbitrary number types but does not achieve as good scaling as BLAS-based LU implementations. Has low overhead and is good for small matrices.</p><p><strong>Positional Arguments</strong></p><ul><li>pivot: The choice of pivoting. Defaults to <code>LinearAlgebra.RowMaximum()</code>. The other choice is <code>LinearAlgebra.NoPivot()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/factorization.jl#L50-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.QRFactorization" href="#LinearSolve.QRFactorization"><code>LinearSolve.QRFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>QRFactorization(pivot=LinearAlgebra.NoPivot(),blocksize=16)</code></p><p>Julia&#39;s built in <code>qr</code>. Equivalent to calling <code>qr!(A)</code>.</p><ul><li>On dense matrices, this uses the current BLAS implementation of the user&#39;s computer</li></ul><p>which by default is OpenBLAS but will use MKL if the user does <code>using MKL</code> in their system.</p><ul><li>On sparse matrices, this will use SPQR from SuiteSparse</li><li>On CuMatrix, it will use a CUDA-accelerated QR from CuSolver.</li><li>On BandedMatrix and BlockBandedMatrix, it will use a banded QR.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/factorization.jl#L134-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.SVDFactorization" href="#LinearSolve.SVDFactorization"><code>LinearSolve.SVDFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SVDFactorization(full=false,alg=LinearAlgebra.DivideAndConquer())</code></p><p>Julia&#39;s built in <code>svd</code>. Equivalent to <code>svd!(A)</code>.</p><ul><li>On dense matrices, this uses the current BLAS implementation of the user&#39;s computer</li></ul><p>which by default is OpenBLAS but will use MKL if the user does <code>using MKL</code> in their system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/factorization.jl#L355-L363">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.CholeskyFactorization" href="#LinearSolve.CholeskyFactorization"><code>LinearSolve.CholeskyFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>CholeskyFactorization(; pivot = nothing, tol = 0.0, shift = 0.0, perm = nothing)</code></p><p>Julia&#39;s built in <code>cholesky</code>. Equivalent to calling <code>cholesky!(A)</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li>pivot: defaluts to NoPivot, can also be RowMaximum.</li><li>tol: the tol argument in CHOLMOD. Only used for sparse matrices.</li><li>shift: the shift argument in CHOLMOD. Only used for sparse matrices.</li><li>perm: the perm argument in CHOLMOD. Only used for sparse matrices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/factorization.jl#L221-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.BunchKaufmanFactorization" href="#LinearSolve.BunchKaufmanFactorization"><code>LinearSolve.BunchKaufmanFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>BunchKaufmanFactorization(; rook = false)</code></p><p>Julia&#39;s built in <code>bunchkaufman</code>. Equivalent to calling <code>bunchkaufman(A)</code>. Only for Symmetric matrices.</p><p><strong>Keyword Arguments</strong></p><ul><li>rook: whether to perform rook pivoting. Defaults to false.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/factorization.jl#L408-L417">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.CHOLMODFactorization" href="#LinearSolve.CHOLMODFactorization"><code>LinearSolve.CHOLMODFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>CHOLMODFactorization(; shift = 0.0, perm = nothing)</code></p><p>A wrapper of CHOLMOD&#39;s polyalgorithm, mixing Cholesky factorization and ldlt. Tries cholesky for performance and retries ldlt if conditioning causes Cholesky to fail.</p><p>Only supports sparse matrices.</p><p><strong>Keyword Arguments</strong></p><ul><li>shift: the shift argument in CHOLMOD.</li><li>perm: the perm argument in CHOLMOD</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/factorization.jl#L852-L865">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.NormalCholeskyFactorization" href="#LinearSolve.NormalCholeskyFactorization"><code>LinearSolve.NormalCholeskyFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>NormalCholeskyFactorization(pivot = RowMaximum())</code></p><p>A fast factorization which uses a Cholesky factorization on A * A&#39;. Can be much faster than LU factorization, but is not as numerically stable and thus should only be applied to well-conditioned matrices.</p><p><strong>Positional Arguments</strong></p><ul><li>pivot: Defaults to RowMaximum(), but can be NoPivot()</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/factorization.jl#L993-L1003">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.NormalBunchKaufmanFactorization" href="#LinearSolve.NormalBunchKaufmanFactorization"><code>LinearSolve.NormalBunchKaufmanFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>NormalBunchKaufmanFactorization(rook = false)</code></p><p>A fast factorization which uses a BunchKaufman factorization on A * A&#39;. Can be much faster than LU factorization, but is not as numerically stable and thus should only be applied to well-conditioned matrices.</p><p><strong>Positional Arguments</strong></p><ul><li>rook: whether to perform rook pivoting. Defaults to false.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/factorization.jl#L1113-L1123">source</a></section></article><h3 id="LinearSolve.jl"><a class="docs-heading-anchor" href="#LinearSolve.jl">LinearSolve.jl</a><a id="LinearSolve.jl-1"></a><a class="docs-heading-anchor-permalink" href="#LinearSolve.jl" title="Permalink"></a></h3><p>LinearSolve.jl contains some linear solvers built in for specailized cases.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.SimpleLUFactorization" href="#LinearSolve.SimpleLUFactorization"><code>LinearSolve.SimpleLUFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SimpleLUFactorization(pivot::Bool = true)</code></p><p>A simple LU-factorization implementation without BLAS. Fast for small matrices.</p><p><strong>Positional Arguments</strong></p><ul><li>pivot::Bool: whether to perform pivoting. Defaults to <code>true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/simplelu.jl#L116-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.DiagonalFactorization" href="#LinearSolve.DiagonalFactorization"><code>LinearSolve.DiagonalFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>DiagonalFactorization()</code></p><p>A special implementation only for solving <code>Diagonal</code> matrices fast.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/factorization.jl#L1156-L1160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.SimpleGMRES" href="#LinearSolve.SimpleGMRES"><code>LinearSolve.SimpleGMRES</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimpleGMRES(; restart::Bool = true, blocksize::Int = 0, warm_start::Bool = false,
    memory::Int = 20)</code></pre><p>A simple GMRES implementation for square non-Hermitian linear systems.</p><p>This implementation handles Block Diagonal Matrices with Uniformly Sized Square Blocks with specialized dispatches.</p><p><strong>Arguments</strong></p><ul><li><code>restart::Bool</code>: If <code>true</code>, then the solver will restart after <code>memory</code> iterations.</li><li><code>memory::Int = 20</code>: The number of iterations before restarting. If restart is false, this value is used to allocate memory and later expanded if more memory is required.</li><li><code>blocksize::Int = 0</code>: If blocksize is <code>&gt; 0</code>, the solver assumes that the matrix has a uniformly sized block diagonal structure with square blocks of size <code>blocksize</code>. Misusing this option will lead to incorrect results.<ul><li>If this is set <code>≤ 0</code> and during runtime we get a Block Diagonal Matrix, then we will check if the specialized dispatch can be used.</li></ul></li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Most users should be using the <code>KrylovJL_GMRES</code> solver instead of this implementation.</p></div></div><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>We can automatically detect if the matrix is a Block Diagonal Matrix with Uniformly Sized Square Blocks. If this is the case, then we can use a specialized dispatch. However, on most modern systems performing a single matrix-vector multiplication is faster than performing multiple smaller matrix-vector multiplications (as in the case of Block Diagonal Matrix). We recommend making the matrix dense (if size permits) and specifying the <code>blocksize</code> argument.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/simplegmres.jl#L1-L33">source</a></section></article><h3 id="FastLapackInterface.jl"><a class="docs-heading-anchor" href="#FastLapackInterface.jl">FastLapackInterface.jl</a><a id="FastLapackInterface.jl-1"></a><a class="docs-heading-anchor-permalink" href="#FastLapackInterface.jl" title="Permalink"></a></h3><p>FastLapackInterface.jl is a package that allows for a lower-level interface to the LAPACK calls to allow for preallocating workspaces to decrease the overhead of the wrappers. LinearSolve.jl provides a wrapper to these routines in a way where an initialized solver has a non-allocating LU factorization. In theory, this post-initialized solve should always be faster than the Base.LinearAlgebra version.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.FastLUFactorization" href="#LinearSolve.FastLUFactorization"><code>LinearSolve.FastLUFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>FastLUFactorization()</code></p><p>The FastLapackInterface.jl version of the LU factorization. Notably, this version does not allow for choice of pivoting method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/factorization.jl#L1191-L1196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.FastQRFactorization" href="#LinearSolve.FastQRFactorization"><code>LinearSolve.FastQRFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>FastQRFactorization()</code></p><p>The FastLapackInterface.jl version of the QR factorization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/factorization.jl#L1222-L1226">source</a></section></article><h3 id="SuiteSparse.jl"><a class="docs-heading-anchor" href="#SuiteSparse.jl">SuiteSparse.jl</a><a id="SuiteSparse.jl-1"></a><a class="docs-heading-anchor-permalink" href="#SuiteSparse.jl" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.KLUFactorization" href="#LinearSolve.KLUFactorization"><code>LinearSolve.KLUFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>KLUFactorization(;reuse_symbolic=true, check_pattern=true)</code></p><p>A fast sparse LU-factorization which specializes on sparsity patterns with “less structure”.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By default, the SuiteSparse.jl are implemented for efficiency by caching the symbolic factorization. I.e., if <code>set_A</code> is used, it is expected that the new <code>A</code> has the same sparsity pattern as the previous <code>A</code>. If this algorithm is to be used in a context where that assumption does not hold, set <code>reuse_symbolic=false</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/factorization.jl#L769-L780">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.UMFPACKFactorization" href="#LinearSolve.UMFPACKFactorization"><code>LinearSolve.UMFPACKFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>UMFPACKFactorization(;reuse_symbolic=true, check_pattern=true)</code></p><p>A fast sparse multithreaded LU-factorization which specializes on sparsity patterns with “more structure”.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By default, the SuiteSparse.jl are implemented for efficiency by caching the symbolic factorization. I.e., if <code>set_A</code> is used, it is expected that the new <code>A</code> has the same sparsity pattern as the previous <code>A</code>. If this algorithm is to be used in a context where that assumption does not hold, set <code>reuse_symbolic=false</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/factorization.jl#L676-L688">source</a></section></article><h3 id="Sparspak.jl"><a class="docs-heading-anchor" href="#Sparspak.jl">Sparspak.jl</a><a id="Sparspak.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Sparspak.jl" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.SparspakFactorization" href="#LinearSolve.SparspakFactorization"><code>LinearSolve.SparspakFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SparspakFactorization(reuse_symbolic = true)</code></p><p>This is the translation of the well-known sparse matrix software Sparspak (Waterloo Sparse Matrix Package), solving large sparse systems of linear algebraic equations. Sparspak is composed of the subroutines from the book &quot;Computer Solution of Large Sparse Positive Definite Systems&quot; by Alan George and Joseph Liu. Originally written in Fortran 77, later rewritten in Fortran 90. Here is the software translated into Julia.</p><p>The Julia rewrite is released  under the MIT license with an express permission from the authors of the Fortran package. The package uses multiple dispatch to route around standard BLAS routines in the case e.g. of arbitrary-precision floating point numbers or ForwardDiff.Dual. This e.g. allows for Automatic Differentiation (AD) of a sparse-matrix solve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/factorization.jl#L1304-L1319">source</a></section></article><h3 id="Krylov.jl"><a class="docs-heading-anchor" href="#Krylov.jl">Krylov.jl</a><a id="Krylov.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Krylov.jl" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.KrylovJL_CG" href="#LinearSolve.KrylovJL_CG"><code>LinearSolve.KrylovJL_CG</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">KrylovJL_CG(args...;  kwargs...)</code></pre><p>A generic CG implementation for Hermitian and positive definite linear systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/iterative_wrappers.jl#L31-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.KrylovJL_MINRES" href="#LinearSolve.KrylovJL_MINRES"><code>LinearSolve.KrylovJL_MINRES</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">KrylovJL_MINRES(args...;  kwargs...)</code></pre><p>A generic MINRES implementation for Hermitian linear systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/iterative_wrappers.jl#L42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.KrylovJL_GMRES" href="#LinearSolve.KrylovJL_GMRES"><code>LinearSolve.KrylovJL_GMRES</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">KrylovJL_GMRES(args...;  gmres_restart = 0, window = 0, kwargs...)</code></pre><p>A generic GMRES implementation for square non-Hermitian linear systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/iterative_wrappers.jl#L53-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.KrylovJL_BICGSTAB" href="#LinearSolve.KrylovJL_BICGSTAB"><code>LinearSolve.KrylovJL_BICGSTAB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">KrylovJL_BICGSTAB(args...;  kwargs...)</code></pre><p>A generic BICGSTAB implementation for square non-Hermitian linear systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/iterative_wrappers.jl#L64-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.KrylovJL_LSMR" href="#LinearSolve.KrylovJL_LSMR"><code>LinearSolve.KrylovJL_LSMR</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">KrylovJL_LSMR(args...;  kwargs...)</code></pre><p>A generic LSMR implementation for least-squares problems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/iterative_wrappers.jl#L75-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.KrylovJL_CRAIGMR" href="#LinearSolve.KrylovJL_CRAIGMR"><code>LinearSolve.KrylovJL_CRAIGMR</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">KrylovJL_CRAIGMR(args...;  kwargs...)</code></pre><p>A generic CRAIGMR implementation for least-norm problems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/iterative_wrappers.jl#L86-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.KrylovJL" href="#LinearSolve.KrylovJL"><code>LinearSolve.KrylovJL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KrylovJL(args...; KrylovAlg = Krylov.gmres!,
         Pl = nothing, Pr = nothing,
         gmres_restart = 0, window = 0,
         kwargs...)</code></pre><p>A generic wrapper over the Krylov.jl krylov-subspace iterative solvers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/iterative_wrappers.jl#L3-L12">source</a></section></article><h3 id="MKL.jl"><a class="docs-heading-anchor" href="#MKL.jl">MKL.jl</a><a id="MKL.jl-1"></a><a class="docs-heading-anchor-permalink" href="#MKL.jl" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package MKL<em>jll.jl, i.e. `using MKL</em>jll`</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.MKLLUFactorization" href="#LinearSolve.MKLLUFactorization"><code>LinearSolve.MKLLUFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MKLLUFactorization()</code></pre><p>A wrapper over Intel&#39;s Math Kernel Library (MKL). Direct calls to MKL in a way that pre-allocates workspace to avoid allocations and does not require libblastrampoline.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/mkl.jl#L1-L8">source</a></section></article><h3 id="AppleAccelerate.jl"><a class="docs-heading-anchor" href="#AppleAccelerate.jl">AppleAccelerate.jl</a><a id="AppleAccelerate.jl-1"></a><a class="docs-heading-anchor-permalink" href="#AppleAccelerate.jl" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires a Mac with Apple Accelerate. This should come standard in most &quot;modern&quot; Mac computers.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.AppleAccelerateLUFactorization" href="#LinearSolve.AppleAccelerateLUFactorization"><code>LinearSolve.AppleAccelerateLUFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AppleAccelerateLUFactorization()</code></pre><p>A wrapper over Apple&#39;s Accelerate Library. Direct calls to Acceelrate in a way that pre-allocates workspace to avoid allocations and does not require libblastrampoline.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/appleaccelerate.jl#L7-L14">source</a></section></article><h3 id="Metal.jl"><a class="docs-heading-anchor" href="#Metal.jl">Metal.jl</a><a id="Metal.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Metal.jl" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package Metal.jl, i.e. <code>using Metal</code>. This package is only compatible with Mac M-Series computers with a Metal-compatible GPU.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.MetalLUFactorization" href="#LinearSolve.MetalLUFactorization"><code>LinearSolve.MetalLUFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MetalLUFactorization()</code></pre><p>A wrapper over Apple&#39;s Metal GPU library. Direct calls to Metal in a way that pre-allocates workspace to avoid allocations and automatically offloads to the GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/extension_algs.jl#L357-L364">source</a></section></article><h3 id="Pardiso.jl"><a class="docs-heading-anchor" href="#Pardiso.jl">Pardiso.jl</a><a id="Pardiso.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Pardiso.jl" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package Pardiso.jl, i.e. <code>using Pardiso</code></p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.MKLPardisoFactorize" href="#LinearSolve.MKLPardisoFactorize"><code>LinearSolve.MKLPardisoFactorize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">MKLPardisoFactorize(; nprocs::Union{Int, Nothing} = nothing,
                    matrix_type = nothing,
                    iparm::Union{Vector{Tuple{Int, Int}}, Nothing} = nothing,
                    dparm::Union{Vector{Tuple{Int, Int}}, Nothing} = nothing)</code></pre><p>A sparse factorization method using MKL Pardiso.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package Pardiso.jl, i.e. <code>using Pardiso</code></p></div></div><p><strong>Keyword Arguments</strong></p><p>For the definition of the keyword arguments, see the Pardiso.jl documentation. All values default to <code>nothing</code> and the solver internally determines the values given the input types, and these keyword arguments are only for overriding the default handling process. This should not be required by most users.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/extension_algs.jl#L90-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.MKLPardisoIterate" href="#LinearSolve.MKLPardisoIterate"><code>LinearSolve.MKLPardisoIterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">MKLPardisoIterate(; nprocs::Union{Int, Nothing} = nothing,
                    matrix_type = nothing,
                    iparm::Union{Vector{Tuple{Int, Int}}, Nothing} = nothing,
                    dparm::Union{Vector{Tuple{Int, Int}}, Nothing} = nothing)</code></pre><p>A mixed factorization+iterative method using MKL Pardiso.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package Pardiso.jl, i.e. <code>using Pardiso</code></p></div></div><p><strong>Keyword Arguments</strong></p><p>For the definition of the keyword arguments, see the Pardiso.jl documentation. All values default to <code>nothing</code> and the solver internally determines the values given the input types, and these keyword arguments are only for overriding the default handling process. This should not be required by most users.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/extension_algs.jl#L113-L133">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>LinearSolve.PardisoJL</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="CUDA.jl"><a class="docs-heading-anchor" href="#CUDA.jl">CUDA.jl</a><a id="CUDA.jl-1"></a><a class="docs-heading-anchor-permalink" href="#CUDA.jl" title="Permalink"></a></h3><p>Note that <code>CuArrays</code> are supported by <code>GenericFactorization</code> in the “normal” way. The following are non-standard GPU factorization routines.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package CUDA.jl, i.e. <code>using CUDA</code></p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.CudaOffloadFactorization" href="#LinearSolve.CudaOffloadFactorization"><code>LinearSolve.CudaOffloadFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>CudaOffloadFactorization()</code></p><p>An offloading technique used to GPU-accelerate CPU-based computations.  Requires a sufficiently large <code>A</code> to overcome the data transfer costs.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package CUDA.jl, i.e. <code>using CUDA</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/extension_algs.jl#L67-L76">source</a></section></article><h3 id="IterativeSolvers.jl"><a class="docs-heading-anchor" href="#IterativeSolvers.jl">IterativeSolvers.jl</a><a id="IterativeSolvers.jl-1"></a><a class="docs-heading-anchor-permalink" href="#IterativeSolvers.jl" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using these solvers requires adding the package IterativeSolvers.jl, i.e. <code>using IterativeSolvers</code></p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.IterativeSolversJL_CG" href="#LinearSolve.IterativeSolversJL_CG"><code>LinearSolve.IterativeSolversJL_CG</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">IterativeSolversJL_CG(args...; Pl = nothing, Pr = nothing, kwargs...)</code></pre><p>A wrapper over the IterativeSolvers.jl CG.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package IterativeSolvers.jl, i.e. <code>using IterativeSolvers</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/extension_algs.jl#L283-L294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.IterativeSolversJL_GMRES" href="#LinearSolve.IterativeSolversJL_GMRES"><code>LinearSolve.IterativeSolversJL_GMRES</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">IterativeSolversJL_GMRES(args...; Pl = nothing, Pr = nothing, gmres_restart=0, kwargs...)</code></pre><p>A wrapper over the IterativeSolvers.jl GMRES.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package IterativeSolvers.jl, i.e. <code>using IterativeSolvers</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/extension_algs.jl#L297-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.IterativeSolversJL_BICGSTAB" href="#LinearSolve.IterativeSolversJL_BICGSTAB"><code>LinearSolve.IterativeSolversJL_BICGSTAB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">IterativeSolversJL_BICGSTAB(args...; Pl = nothing, Pr = nothing, kwargs...)</code></pre><p>A wrapper over the IterativeSolvers.jl BICGSTAB.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package IterativeSolvers.jl, i.e. <code>using IterativeSolvers</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/extension_algs.jl#L327-L339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.IterativeSolversJL_MINRES" href="#LinearSolve.IterativeSolversJL_MINRES"><code>LinearSolve.IterativeSolversJL_MINRES</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">IterativeSolversJL_MINRES(args...; Pl = nothing, Pr = nothing, kwargs...)</code></pre><p>A wrapper over the IterativeSolvers.jl MINRES.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package IterativeSolvers.jl, i.e. <code>using IterativeSolvers</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/extension_algs.jl#L342-L354">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.IterativeSolversJL_IDRS" href="#LinearSolve.IterativeSolversJL_IDRS"><code>LinearSolve.IterativeSolversJL_IDRS</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">IterativeSolversJL_IDRS(args...; Pl = nothing, kwargs...)</code></pre><p>A wrapper over the IterativeSolvers.jl IDR(S).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package IterativeSolvers.jl, i.e. <code>using IterativeSolvers</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/extension_algs.jl#L312-L324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.IterativeSolversJL" href="#LinearSolve.IterativeSolversJL"><code>LinearSolve.IterativeSolversJL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IterativeSolversJL(args...;
                   generate_iterator = IterativeSolvers.gmres_iterable!,
                   Pl = nothing, Pr = nothing,
                   gmres_restart = 0, kwargs...)</code></pre><p>A generic wrapper over the IterativeSolvers.jl solvers.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package IterativeSolvers.jl, i.e. <code>using IterativeSolvers</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/extension_algs.jl#L260-L275">source</a></section></article><h3 id="KrylovKit.jl"><a class="docs-heading-anchor" href="#KrylovKit.jl">KrylovKit.jl</a><a id="KrylovKit.jl-1"></a><a class="docs-heading-anchor-permalink" href="#KrylovKit.jl" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using these solvers requires adding the package KrylovKit.jl, i.e. <code>using KrylovKit</code></p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.KrylovKitJL_CG" href="#LinearSolve.KrylovKitJL_CG"><code>LinearSolve.KrylovKitJL_CG</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">KrylovKitJL_CG(args...; Pl = nothing, Pr = nothing, kwargs...)</code></pre><p>A generic CG implementation for Hermitian and positive definite linear systems</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package KrylovKit.jl, i.e. <code>using KrylovKit</code>    </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/extension_algs.jl#L234-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.KrylovKitJL_GMRES" href="#LinearSolve.KrylovKitJL_GMRES"><code>LinearSolve.KrylovKitJL_GMRES</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">KrylovKitJL_GMRES(args...; Pl = nothing, Pr = nothing, gmres_restart = 0, kwargs...)</code></pre><p>A generic GMRES implementation.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package KrylovKit.jl, i.e. <code>using KrylovKit</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/extension_algs.jl#L247-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.KrylovKitJL" href="#LinearSolve.KrylovKitJL"><code>LinearSolve.KrylovKitJL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KrylovKitJL(args...; KrylovAlg = Krylov.gmres!, kwargs...)</code></pre><p>A generic iterative solver implementation allowing the choice of KrylovKit.jl solvers.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package KrylovKit.jl, i.e. <code>using KrylovKit</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/extension_algs.jl#L215-L226">source</a></section></article><h3 id="HYPRE.jl"><a class="docs-heading-anchor" href="#HYPRE.jl">HYPRE.jl</a><a id="HYPRE.jl-1"></a><a class="docs-heading-anchor-permalink" href="#HYPRE.jl" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using HYPRE solvers requires Julia version 1.9 or higher, and that the package HYPRE.jl is installed.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.HYPREAlgorithm" href="#LinearSolve.HYPREAlgorithm"><code>LinearSolve.HYPREAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>HYPREAlgorithm(solver; Pl = nothing)</code></p><p><a href="https://github.com/fredrikekre/HYPRE.jl">HYPRE.jl</a> is an interface to <a href="https://computing.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods"><code>hypre</code></a> and provide iterative solvers and preconditioners for sparse linear systems. It is mainly developed for large multi-process distributed problems (using MPI), but can also be used for single-process problems with Julias standard sparse matrices.</p><p>If you need more fine-grained control over the solver/preconditioner options you can alternatively pass an already created solver to <code>HYPREAlgorithm</code> (and to the <code>Pl</code> keyword argument). See HYPRE.jl docs for how to set up solvers with specific options.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using HYPRE solvers requires Julia version 1.9 or higher, and that the package HYPRE.jl is installed.</p></div></div><p><strong>Positional Arguments</strong></p><p>The single positional argument <code>solver</code> has the following choices:</p><ul><li><code>HYPRE.BiCGSTAB</code></li><li><code>HYPRE.BoomerAMG</code></li><li><code>HYPRE.FlexGMRES</code></li><li><code>HYPRE.GMRES</code></li><li><code>HYPRE.Hybrid</code></li><li><code>HYPRE.ILU</code></li><li><code>HYPRE.ParaSails</code> (as preconditioner only)</li><li><code>HYPRE.PCG</code></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Pl</code>: A choice of left preconditioner.</li></ul><p><strong>Example</strong></p><p>For example, to use <code>HYPRE.PCG</code> as the solver, with <code>HYPRE.BoomerAMG</code> as the preconditioner, the algorithm should be defined as follows:</p><pre><code class="language-julia hljs">A, b = setup_system(...)
prob = LinearProblem(A, b)
alg = HYPREAlgorithm(HYPRE.PCG)
prec = HYPRE.BoomerAMG
sol = solve(prob, alg; Pl = prec)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/5a8aa51e7011a43062c89e2f689638a89241ec80/src/extension_algs.jl#L4-L51">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../basics/FAQ/">« Frequently Asked Questions</a><a class="docs-footer-nextpage" href="../../advanced/developing/">Developing New Linear Solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Friday 27 October 2023 06:13">Friday 27 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
