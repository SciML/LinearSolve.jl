<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear System Solvers · LinearSolve.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/LinearSolve/stable/solvers/solvers/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="LinearSolve.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LinearSolve.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">LinearSolve.jl: High-Performance Unified Linear Solvers</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/linear/">Solving Linear Systems in Julia</a></li><li><a class="tocitem" href="../../tutorials/caching_interface/">Linear Solve with Caching Interface</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/LinearProblem/">Linear Problems</a></li><li><a class="tocitem" href="../../basics/common_solver_opts/">Common Solver Options (Keyword Arguments for Solve)</a></li><li><a class="tocitem" href="../../basics/OperatorAssumptions/">Linear Solve Operator Assumptions</a></li><li><a class="tocitem" href="../../basics/Preconditioners/">Preconditioners</a></li><li><a class="tocitem" href="../../basics/FAQ/">Frequently Asked Questions</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li class="is-active"><a class="tocitem" href>Linear System Solvers</a><ul class="internal"><li><a class="tocitem" href="#Recommended-Methods"><span>Recommended Methods</span></a></li><li><a class="tocitem" href="#Full-List-of-Methods"><span>Full List of Methods</span></a></li></ul></li></ul></li><li><span class="tocitem">Advanced</span><ul><li><a class="tocitem" href="../../advanced/developing/">Developing New Linear Solvers</a></li><li><a class="tocitem" href="../../advanced/custom/">Passing in a Custom Linear Solver</a></li></ul></li><li><a class="tocitem" href="../../release_notes/">Release Notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solvers</a></li><li class="is-active"><a href>Linear System Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linear System Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/LinearSolve.jl/blob/main/docs/src/solvers/solvers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="linearsystemsolvers"><a class="docs-heading-anchor" href="#linearsystemsolvers">Linear System Solvers</a><a id="linearsystemsolvers-1"></a><a class="docs-heading-anchor-permalink" href="#linearsystemsolvers" title="Permalink"></a></h1><p><code>solve(prob::LinearProblem,alg;kwargs)</code></p><p>Solves for <span>$Au=b$</span> in the problem defined by <code>prob</code> using the algorithm <code>alg</code>. If no algorithm is given, a default algorithm will be chosen.</p><h2 id="Recommended-Methods"><a class="docs-heading-anchor" href="#Recommended-Methods">Recommended Methods</a><a id="Recommended-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Recommended-Methods" title="Permalink"></a></h2><p>The default algorithm <code>nothing</code> is good for picking an algorithm that will work, but one may need to change this to receive more performance or precision. If more precision is necessary, <code>QRFactorization()</code> and <code>SVDFactorization()</code> are the best choices, with SVD being the slowest but most precise.</p><p>For efficiency, <code>RFLUFactorization</code> is the fastest for dense LU-factorizations. <code>FastLUFactorization</code> will be faster than <code>LUFactorization</code> which is the Base.LinearAlgebra (<code>\</code> default) implementation of LU factorization. <code>SimpleLUFactorization</code> will be fast on very small matrices.</p><p>For sparse LU-factorizations, <code>KLUFactorization</code> if there is less structure to the sparsity pattern and <code>UMFPACKFactorization</code> if there is more structure. Pardiso.jl&#39;s methods are also known to be very efficient sparse linear solvers.</p><p>While these sparse factorizations are based on implementations in other languages, and therefore constrained to standard number types (<code>Float64</code>,  <code>Float32</code> and their complex counterparts),  <code>SparspakFactorization</code> is able to handle general number types, e.g. defined by <code>ForwardDiff.jl</code>, <code>MultiFloats.jl</code>, or <code>IntervalArithmetics.jl</code>.</p><p>As sparse matrices get larger, iterative solvers tend to get more efficient than factorization methods if a lower tolerance of the solution is required.</p><p>Krylov.jl generally outperforms IterativeSolvers.jl and KrylovKit.jl, and is compatible with CPUs and GPUs, and thus is the generally preferred form for Krylov methods.</p><p>Finally, a user can pass a custom function for handling the linear solve using <code>LinearSolveFunction()</code> if existing solvers are not optimally suited for their application. The interface is detailed <a href="../../advanced/custom/#custom">here</a>.</p><h2 id="Full-List-of-Methods"><a class="docs-heading-anchor" href="#Full-List-of-Methods">Full List of Methods</a><a id="Full-List-of-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Full-List-of-Methods" title="Permalink"></a></h2><h3 id="RecursiveFactorization.jl"><a class="docs-heading-anchor" href="#RecursiveFactorization.jl">RecursiveFactorization.jl</a><a id="RecursiveFactorization.jl-1"></a><a class="docs-heading-anchor-permalink" href="#RecursiveFactorization.jl" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.RFLUFactorization" href="#LinearSolve.RFLUFactorization"><code>LinearSolve.RFLUFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>RFLUFactorization()</code> </p><p>A fast pure Julia LU-factorization implementation using RecursiveFactorization.jl. This is by far the fastest LU-factorization implementation, usually outperforming OpenBLAS and MKL for smaller matrices (&lt;500x500), but currently optimized only for Base <code>Array</code> with <code>Float32</code> or <code>Float64</code>.   Additional optimization for complex matrices is in the works.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/factorization.jl#L918-L926">source</a></section></article><h3 id="Base.LinearAlgebra"><a class="docs-heading-anchor" href="#Base.LinearAlgebra">Base.LinearAlgebra</a><a id="Base.LinearAlgebra-1"></a><a class="docs-heading-anchor-permalink" href="#Base.LinearAlgebra" title="Permalink"></a></h3><p>These overloads tend to work for many array types, such as <code>CuArrays</code> for GPU-accelerated solving, using the overloads provided by the respective packages. Given that this can be customized per-package, details given below describe a subset of important arrays (<code>Matrix</code>, <code>SparseMatrixCSC</code>, <code>CuMatrix</code>, etc.)</p><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.LUFactorization" href="#LinearSolve.LUFactorization"><code>LinearSolve.LUFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>LUFactorization(pivot=LinearAlgebra.RowMaximum())</code></p><p>Julia&#39;s built in <code>lu</code>. Equivalent to calling <code>lu!(A)</code></p><ul><li>On dense matrices, this uses the current BLAS implementation of the user&#39;s computer,</li></ul><p>which by default is OpenBLAS but will use MKL if the user does <code>using MKL</code> in their system.</p><ul><li>On sparse matrices, this will use UMFPACK from SuiteSparse. Note that this will not</li></ul><p>cache the symbolic factorization.</p><ul><li>On CuMatrix, it will use a CUDA-accelerated LU from CuSolver.</li><li>On BandedMatrix and BlockBandedMatrix, it will use a banded LU.</li></ul><p><strong>Positional Arguments</strong></p><ul><li>pivot: The choice of pivoting. Defaults to <code>LinearAlgebra.RowMaximum()</code>. The other choice is <code>LinearAlgebra.NoPivot()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/factorization.jl#L28-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.GenericLUFactorization" href="#LinearSolve.GenericLUFactorization"><code>LinearSolve.GenericLUFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>GenericLUFactorization(pivot=LinearAlgebra.RowMaximum())</code></p><p>Julia&#39;s built in generic LU factorization. Equivalent to calling LinearAlgebra.generic_lufact!. Supports arbitrary number types but does not achieve as good scaling as BLAS-based LU implementations. Has low overhead and is good for small matrices.</p><p><strong>Positional Arguments</strong></p><ul><li>pivot: The choice of pivoting. Defaults to <code>LinearAlgebra.RowMaximum()</code>. The other choice is <code>LinearAlgebra.NoPivot()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/factorization.jl#L50-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.QRFactorization" href="#LinearSolve.QRFactorization"><code>LinearSolve.QRFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>QRFactorization(pivot=LinearAlgebra.NoPivot(),blocksize=16)</code></p><p>Julia&#39;s built in <code>qr</code>. Equivalent to calling <code>qr!(A)</code>.</p><ul><li>On dense matrices, this uses the current BLAS implementation of the user&#39;s computer</li></ul><p>which by default is OpenBLAS but will use MKL if the user does <code>using MKL</code> in their system.</p><ul><li>On sparse matrices, this will use SPQR from SuiteSparse</li><li>On CuMatrix, it will use a CUDA-accelerated QR from CuSolver.</li><li>On BandedMatrix and BlockBandedMatrix, it will use a banded QR.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/factorization.jl#L134-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.SVDFactorization" href="#LinearSolve.SVDFactorization"><code>LinearSolve.SVDFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SVDFactorization(full=false,alg=LinearAlgebra.DivideAndConquer())</code></p><p>Julia&#39;s built in <code>svd</code>. Equivalent to <code>svd!(A)</code>.</p><ul><li>On dense matrices, this uses the current BLAS implementation of the user&#39;s computer</li></ul><p>which by default is OpenBLAS but will use MKL if the user does <code>using MKL</code> in their system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/factorization.jl#L345-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.CholeskyFactorization" href="#LinearSolve.CholeskyFactorization"><code>LinearSolve.CholeskyFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>CholeskyFactorization(; pivot = nothing, tol = 0.0, shift = 0.0, perm = nothing)</code></p><p>Julia&#39;s built in <code>cholesky</code>. Equivalent to calling <code>cholesky!(A)</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li>pivot: defaluts to NoPivot, can also be RowMaximum.</li><li>tol: the tol argument in CHOLMOD. Only used for sparse matrices.</li><li>shift: the shift argument in CHOLMOD. Only used for sparse matrices.</li><li>perm: the perm argument in CHOLMOD. Only used for sparse matrices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/factorization.jl#L211-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.BunchKaufmanFactorization" href="#LinearSolve.BunchKaufmanFactorization"><code>LinearSolve.BunchKaufmanFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>BunchKaufmanFactorization(; rook = false)</code></p><p>Julia&#39;s built in <code>bunchkaufman</code>. Equivalent to calling <code>bunchkaufman(A)</code>. Only for Symmetric matrices.</p><p><strong>Keyword Arguments</strong></p><ul><li>rook: whether to perform rook pivoting. Defaults to false.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/factorization.jl#L398-L407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.CHOLMODFactorization" href="#LinearSolve.CHOLMODFactorization"><code>LinearSolve.CHOLMODFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>CHOLMODFactorization(; shift = 0.0, perm = nothing)</code></p><p>A wrapper of CHOLMOD&#39;s polyalgorithm, mixing Cholesky factorization and ldlt. Tries cholesky for performance and retries ldlt if conditioning causes Cholesky to fail.</p><p>Only supports sparse matrices.</p><p><strong>Keyword Arguments</strong></p><ul><li>shift: the shift argument in CHOLMOD. </li><li>perm: the perm argument in CHOLMOD</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/factorization.jl#L842-L855">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.NormalCholeskyFactorization" href="#LinearSolve.NormalCholeskyFactorization"><code>LinearSolve.NormalCholeskyFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>NormalCholeskyFactorization(pivot = RowMaximum())</code></p><p>A fast factorization which uses a Cholesky factorization on A * A&#39;. Can be much faster than LU factorization, but is not as numerically stable and thus should only be applied to well-conditioned matrices.</p><p><strong>Positional Arguments</strong></p><ul><li>pivot: Defaults to RowMaximum(), but can be NoPivot()</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/factorization.jl#L983-L993">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.NormalBunchKaufmanFactorization" href="#LinearSolve.NormalBunchKaufmanFactorization"><code>LinearSolve.NormalBunchKaufmanFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>NormalBunchKaufmanFactorization(rook = false)</code></p><p>A fast factorization which uses a BunchKaufman factorization on A * A&#39;. Can be much faster than LU factorization, but is not as numerically stable and thus should only be applied to well-conditioned matrices.</p><p><strong>Positional Arguments</strong></p><ul><li>rook: whether to perform rook pivoting. Defaults to false.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/factorization.jl#L1103-L1113">source</a></section></article><h3 id="LinearSolve.jl"><a class="docs-heading-anchor" href="#LinearSolve.jl">LinearSolve.jl</a><a id="LinearSolve.jl-1"></a><a class="docs-heading-anchor-permalink" href="#LinearSolve.jl" title="Permalink"></a></h3><p>LinearSolve.jl contains some linear solvers built in for specailized cases.</p><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.SimpleLUFactorization" href="#LinearSolve.SimpleLUFactorization"><code>LinearSolve.SimpleLUFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SimpleLUFactorization(pivot::Bool = true)</code></p><p>A simple LU-factorization implementation without BLAS. Fast for small matrices.</p><p><strong>Positional Arguments</strong></p><ul><li>pivot::Bool: whether to perform pivoting. Defaults to <code>true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/simplelu.jl#L116-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.DiagonalFactorization" href="#LinearSolve.DiagonalFactorization"><code>LinearSolve.DiagonalFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>DiagonalFactorization()</code></p><p>A special implementation only for solving <code>Diagonal</code> matrices fast.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/factorization.jl#L1146-L1150">source</a></section></article><h3 id="FastLapackInterface.jl"><a class="docs-heading-anchor" href="#FastLapackInterface.jl">FastLapackInterface.jl</a><a id="FastLapackInterface.jl-1"></a><a class="docs-heading-anchor-permalink" href="#FastLapackInterface.jl" title="Permalink"></a></h3><p>FastLapackInterface.jl is a package that allows for a lower-level interface to the LAPACK calls to allow for preallocating workspaces to decrease the overhead of the wrappers. LinearSolve.jl provides a wrapper to these routines in a way where an initialized solver has a non-allocating LU factorization. In theory, this post-initialized solve should always be faster than the Base.LinearAlgebra version.</p><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.FastLUFactorization" href="#LinearSolve.FastLUFactorization"><code>LinearSolve.FastLUFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>FastLUFactorization()</code> </p><p>The FastLapackInterface.jl version of the LU factorization. Notably, this version does not allow for choice of pivoting method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/factorization.jl#L1181-L1186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.FastQRFactorization" href="#LinearSolve.FastQRFactorization"><code>LinearSolve.FastQRFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>FastQRFactorization()</code> </p><p>The FastLapackInterface.jl version of the QR factorization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/factorization.jl#L1212-L1216">source</a></section></article><h3 id="SuiteSparse.jl"><a class="docs-heading-anchor" href="#SuiteSparse.jl">SuiteSparse.jl</a><a id="SuiteSparse.jl-1"></a><a class="docs-heading-anchor-permalink" href="#SuiteSparse.jl" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.KLUFactorization" href="#LinearSolve.KLUFactorization"><code>LinearSolve.KLUFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>KLUFactorization(;reuse_symbolic=true, check_pattern=true)</code></p><p>A fast sparse LU-factorization which specializes on sparsity patterns with “less structure”.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By default, the SuiteSparse.jl are implemented for efficiency by caching the symbolic factorization. I.e., if <code>set_A</code> is used, it is expected that the new <code>A</code> has the same sparsity pattern as the previous <code>A</code>. If this algorithm is to be used in a context where that assumption does not hold, set <code>reuse_symbolic=false</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/factorization.jl#L759-L770">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.UMFPACKFactorization" href="#LinearSolve.UMFPACKFactorization"><code>LinearSolve.UMFPACKFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>UMFPACKFactorization(;reuse_symbolic=true, check_pattern=true)</code></p><p>A fast sparse multithreaded LU-factorization which specializes on sparsity  patterns with “more structure”.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By default, the SuiteSparse.jl are implemented for efficiency by caching the symbolic factorization. I.e., if <code>set_A</code> is used, it is expected that the new <code>A</code> has the same sparsity pattern as the previous <code>A</code>. If this algorithm is to be used in a context where that assumption does not hold, set <code>reuse_symbolic=false</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/factorization.jl#L666-L678">source</a></section></article><h3 id="Sparspak.jl"><a class="docs-heading-anchor" href="#Sparspak.jl">Sparspak.jl</a><a id="Sparspak.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Sparspak.jl" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.SparspakFactorization" href="#LinearSolve.SparspakFactorization"><code>LinearSolve.SparspakFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SparspakFactorization(reuse_symbolic = true)</code></p><p>This is the translation of the well-known sparse matrix software Sparspak (Waterloo Sparse Matrix Package), solving large sparse systems of linear algebraic equations. Sparspak is composed of the subroutines from the book &quot;Computer Solution of Large Sparse Positive Definite Systems&quot; by Alan George and Joseph Liu. Originally written in Fortran 77, later rewritten in Fortran 90. Here is the software translated into Julia.</p><p>The Julia rewrite is released  under the MIT license with an express permission from the authors of the Fortran package. The package uses multiple dispatch to route around standard BLAS routines in the case e.g. of arbitrary-precision floating point numbers or ForwardDiff.Dual. This e.g. allows for Automatic Differentiation (AD) of a sparse-matrix solve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/factorization.jl#L1294-L1309">source</a></section></article><h3 id="Krylov.jl"><a class="docs-heading-anchor" href="#Krylov.jl">Krylov.jl</a><a id="Krylov.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Krylov.jl" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.KrylovJL_CG" href="#LinearSolve.KrylovJL_CG"><code>LinearSolve.KrylovJL_CG</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">KrylovJL_CG(args...;  kwargs...)</code></pre><p>A generic CG implementation for Hermitian and positive definite linear systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/iterative_wrappers.jl#L31-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.KrylovJL_MINRES" href="#LinearSolve.KrylovJL_MINRES"><code>LinearSolve.KrylovJL_MINRES</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">KrylovJL_MINRES(args...;  kwargs...)</code></pre><p>A generic MINRES implementation for Hermitian linear systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/iterative_wrappers.jl#L42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.KrylovJL_GMRES" href="#LinearSolve.KrylovJL_GMRES"><code>LinearSolve.KrylovJL_GMRES</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">KrylovJL_GMRES(args...;  gmres_restart = 0, window = 0, kwargs...)</code></pre><p>A generic GMRES implementation for square non-Hermitian linear systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/iterative_wrappers.jl#L53-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.KrylovJL_BICGSTAB" href="#LinearSolve.KrylovJL_BICGSTAB"><code>LinearSolve.KrylovJL_BICGSTAB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">KrylovJL_BICGSTAB(args...;  kwargs...)</code></pre><p>A generic BICGSTAB implementation for square non-Hermitian linear systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/iterative_wrappers.jl#L64-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.KrylovJL_LSMR" href="#LinearSolve.KrylovJL_LSMR"><code>LinearSolve.KrylovJL_LSMR</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">KrylovJL_LSMR(args...;  kwargs...)</code></pre><p>A generic LSMR implementation for least-squares problems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/iterative_wrappers.jl#L75-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.KrylovJL_CRAIGMR" href="#LinearSolve.KrylovJL_CRAIGMR"><code>LinearSolve.KrylovJL_CRAIGMR</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">KrylovJL_CRAIGMR(args...;  kwargs...)</code></pre><p>A generic CRAIGMR implementation for least-norm problems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/iterative_wrappers.jl#L86-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.KrylovJL" href="#LinearSolve.KrylovJL"><code>LinearSolve.KrylovJL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KrylovJL(args...; KrylovAlg = Krylov.gmres!,
         Pl = nothing, Pr = nothing,
         gmres_restart = 0, window = 0,
         kwargs...)</code></pre><p>A generic wrapper over the Krylov.jl krylov-subspace iterative solvers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/iterative_wrappers.jl#L3-L12">source</a></section></article><h3 id="Pardiso.jl"><a class="docs-heading-anchor" href="#Pardiso.jl">Pardiso.jl</a><a id="Pardiso.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Pardiso.jl" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package Pardiso.jl, i.e. <code>using Pardiso</code></p></div></div><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.MKLPardisoFactorize" href="#LinearSolve.MKLPardisoFactorize"><code>LinearSolve.MKLPardisoFactorize</code></a> — <span class="docstring-category">Function</span></header><section><div><p>```julia MKLPardisoFactorize(; nprocs::Union{Int, Nothing} = nothing,                     matrix_type = nothing,                     iparm::Union{Vector{Tuple{Int, Int}}, Nothing} = nothing,                     dparm::Union{Vector{Tuple{Int, Int}}, Nothing} = nothing)</p><p>A sparse factorization method using MKL Pardiso.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package Pardiso.jl, i.e. <code>using Pardiso</code></p></div></div><p><strong>Keyword Arguments</strong></p><p>For the definition of the keyword arguments, see the Pardiso.jl documentation. All values default to <code>nothing</code> and the solver internally determines the values given the input types, and these keyword arguments are only for overriding the default handling process. This should not be required by most users.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/extension_algs.jl#L90-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.MKLPardisoIterate" href="#LinearSolve.MKLPardisoIterate"><code>LinearSolve.MKLPardisoIterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">MKLPardisoIterate(; nprocs::Union{Int, Nothing} = nothing,
                    matrix_type = nothing,
                    iparm::Union{Vector{Tuple{Int, Int}}, Nothing} = nothing,
                    dparm::Union{Vector{Tuple{Int, Int}}, Nothing} = nothing)</code></pre><p>A mixed factorization+iterative method using MKL Pardiso.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package Pardiso.jl, i.e. <code>using Pardiso</code></p></div></div><p><strong>Keyword Arguments</strong></p><p>For the definition of the keyword arguments, see the Pardiso.jl documentation. All values default to <code>nothing</code> and the solver internally determines the values given the input types, and these keyword arguments are only for overriding the default handling process. This should not be required by most users.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/extension_algs.jl#L112-L132">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>LinearSolve.PardisoJL</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="CUDA.jl"><a class="docs-heading-anchor" href="#CUDA.jl">CUDA.jl</a><a id="CUDA.jl-1"></a><a class="docs-heading-anchor-permalink" href="#CUDA.jl" title="Permalink"></a></h3><p>Note that <code>CuArrays</code> are supported by <code>GenericFactorization</code> in the “normal” way. The following are non-standard GPU factorization routines.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package CUDA.jl, i.e. <code>using CUDA</code></p></div></div><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.CudaOffloadFactorization" href="#LinearSolve.CudaOffloadFactorization"><code>LinearSolve.CudaOffloadFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>CudaOffloadFactorization()</code></p><p>An offloading technique used to GPU-accelerate CPU-based computations.  Requires a sufficiently large <code>A</code> to overcome the data transfer costs.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package CUDA.jl, i.e. <code>using CUDA</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/extension_algs.jl#L67-L76">source</a></section></article><h3 id="IterativeSolvers.jl"><a class="docs-heading-anchor" href="#IterativeSolvers.jl">IterativeSolvers.jl</a><a id="IterativeSolvers.jl-1"></a><a class="docs-heading-anchor-permalink" href="#IterativeSolvers.jl" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using these solvers requires adding the package IterativeSolvers.jl, i.e. <code>using IterativeSolvers</code></p></div></div><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.IterativeSolversJL_CG" href="#LinearSolve.IterativeSolversJL_CG"><code>LinearSolve.IterativeSolversJL_CG</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">IterativeSolversJL_CG(args...; Pl = nothing, Pr = nothing, kwargs...)</code></pre><p>A wrapper over the IterativeSolvers.jl CG.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package IterativeSolvers.jl, i.e. <code>using IterativeSolvers</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/extension_algs.jl#L282-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.IterativeSolversJL_GMRES" href="#LinearSolve.IterativeSolversJL_GMRES"><code>LinearSolve.IterativeSolversJL_GMRES</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">IterativeSolversJL_GMRES(args...; Pl = nothing, Pr = nothing, gmres_restart=0, kwargs...)</code></pre><p>A wrapper over the IterativeSolvers.jl GMRES.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package IterativeSolvers.jl, i.e. <code>using IterativeSolvers</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/extension_algs.jl#L296-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.IterativeSolversJL_BICGSTAB" href="#LinearSolve.IterativeSolversJL_BICGSTAB"><code>LinearSolve.IterativeSolversJL_BICGSTAB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">IterativeSolversJL_BICGSTAB(args...; Pl = nothing, Pr = nothing, kwargs...)</code></pre><p>A wrapper over the IterativeSolvers.jl BICGSTAB.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package IterativeSolvers.jl, i.e. <code>using IterativeSolvers</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/extension_algs.jl#L311-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.IterativeSolversJL_MINRES" href="#LinearSolve.IterativeSolversJL_MINRES"><code>LinearSolve.IterativeSolversJL_MINRES</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">IterativeSolversJL_MINRES(args...; Pl = nothing, Pr = nothing, kwargs...)</code></pre><p>A wrapper over the IterativeSolvers.jl MINRES.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package IterativeSolvers.jl, i.e. <code>using IterativeSolvers</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/extension_algs.jl#L326-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.IterativeSolversJL" href="#LinearSolve.IterativeSolversJL"><code>LinearSolve.IterativeSolversJL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IterativeSolversJL(args...;
                   generate_iterator = IterativeSolvers.gmres_iterable!,
                   Pl = nothing, Pr = nothing,
                   gmres_restart = 0, kwargs...)</code></pre><p>A generic wrapper over the IterativeSolvers.jl solvers.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package IterativeSolvers.jl, i.e. <code>using IterativeSolvers</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/extension_algs.jl#L259-L274">source</a></section></article><h3 id="KrylovKit.jl"><a class="docs-heading-anchor" href="#KrylovKit.jl">KrylovKit.jl</a><a id="KrylovKit.jl-1"></a><a class="docs-heading-anchor-permalink" href="#KrylovKit.jl" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using these solvers requires adding the package KrylovKit.jl, i.e. <code>using KrylovKit</code></p></div></div><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.KrylovKitJL_CG" href="#LinearSolve.KrylovKitJL_CG"><code>LinearSolve.KrylovKitJL_CG</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">KrylovKitJL_CG(args...; Pl = nothing, Pr = nothing, kwargs...)</code></pre><p>A generic CG implementation for Hermitian and positive definite linear systems</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package KrylovKit.jl, i.e. <code>using KrylovKit</code>    </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/extension_algs.jl#L233-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.KrylovKitJL_GMRES" href="#LinearSolve.KrylovKitJL_GMRES"><code>LinearSolve.KrylovKitJL_GMRES</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">KrylovKitJL_GMRES(args...; Pl = nothing, Pr = nothing, gmres_restart = 0, kwargs...)</code></pre><p>A generic GMRES implementation.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package KrylovKit.jl, i.e. <code>using KrylovKit</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/extension_algs.jl#L246-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.KrylovKitJL" href="#LinearSolve.KrylovKitJL"><code>LinearSolve.KrylovKitJL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KrylovKitJL(args...; KrylovAlg = Krylov.gmres!, kwargs...)</code></pre><p>A generic iterative solver implementation allowing the choice of KrylovKit.jl solvers.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this solver requires adding the package KrylovKit.jl, i.e. <code>using KrylovKit</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/extension_algs.jl#L214-L225">source</a></section></article><h3 id="HYPRE.jl"><a class="docs-heading-anchor" href="#HYPRE.jl">HYPRE.jl</a><a id="HYPRE.jl-1"></a><a class="docs-heading-anchor-permalink" href="#HYPRE.jl" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using HYPRE solvers requires Julia version 1.9 or higher, and that the package HYPRE.jl is installed.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="LinearSolve.HYPREAlgorithm" href="#LinearSolve.HYPREAlgorithm"><code>LinearSolve.HYPREAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>HYPREAlgorithm(solver; Pl = nothing)</code></p><p><a href="https://github.com/fredrikekre/HYPRE.jl">HYPRE.jl</a> is an interface to <a href="https://computing.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods"><code>hypre</code></a> and provide iterative solvers and preconditioners for sparse linear systems. It is mainly developed for large multi-process distributed problems (using MPI), but can also be used for single-process problems with Julias standard sparse matrices.</p><p>If you need more fine-grained control over the solver/preconditioner options you can alternatively pass an already created solver to <code>HYPREAlgorithm</code> (and to the <code>Pl</code> keyword argument). See HYPRE.jl docs for how to set up solvers with specific options.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using HYPRE solvers requires Julia version 1.9 or higher, and that the package HYPRE.jl is installed.</p></div></div><p><strong>Positional Arguments</strong></p><p>The single positional argument <code>solver</code> has the following choices:</p><ul><li><code>HYPRE.BiCGSTAB</code></li><li><code>HYPRE.BoomerAMG</code></li><li><code>HYPRE.FlexGMRES</code></li><li><code>HYPRE.GMRES</code></li><li><code>HYPRE.Hybrid</code></li><li><code>HYPRE.ILU</code></li><li><code>HYPRE.ParaSails</code> (as preconditioner only)</li><li><code>HYPRE.PCG</code></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Pl</code>: A choice of left preconditioner.</li></ul><p><strong>Example</strong></p><p>For example, to use <code>HYPRE.PCG</code> as the solver, with <code>HYPRE.BoomerAMG</code> as the preconditioner, the algorithm should be defined as follows:</p><pre><code class="language-julia hljs">A, b = setup_system(...)
prob = LinearProblem(A, b)
alg = HYPREAlgorithm(HYPRE.PCG)
prec = HYPRE.BoomerAMG
sol = solve(prob, alg; Pl = prec)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e622fa495f238e96e758aac74828c20aa02a966d/src/extension_algs.jl#L4-L51">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../basics/FAQ/">« Frequently Asked Questions</a><a class="docs-footer-nextpage" href="../../advanced/developing/">Developing New Linear Solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Sunday 16 July 2023 23:59">Sunday 16 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
