<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internal API Documentation · LinearSolve.jl</title><meta name="title" content="Internal API Documentation · LinearSolve.jl"/><meta property="og:title" content="Internal API Documentation · LinearSolve.jl"/><meta property="twitter:title" content="Internal API Documentation · LinearSolve.jl"/><meta name="description" content="Documentation for LinearSolve.jl."/><meta property="og:description" content="Documentation for LinearSolve.jl."/><meta property="twitter:description" content="Documentation for LinearSolve.jl."/><meta property="og:url" content="https://docs.sciml.ai/LinearSolve/stable/advanced/internal_api/"/><meta property="twitter:url" content="https://docs.sciml.ai/LinearSolve/stable/advanced/internal_api/"/><link rel="canonical" href="https://docs.sciml.ai/LinearSolve/stable/advanced/internal_api/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="LinearSolve.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LinearSolve.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">LinearSolve.jl: High-Performance Unified Linear Solvers</a></li><li><a class="tocitem" href="../../tutorials/linear/">Getting Started with Solving Linear Systems in Julia</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/caching_interface/">Linear Solve with Caching Interface</a></li><li><a class="tocitem" href="../../tutorials/accelerating_choices/">Accelerating your Linear Solves</a></li><li><a class="tocitem" href="../../tutorials/gpu/">GPU-Accelerated Linear Solving in Julia</a></li><li><a class="tocitem" href="../../tutorials/autotune/">Automatic Algorithm Selection with LinearSolveAutotune</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/LinearProblem/">Linear Problems</a></li><li><a class="tocitem" href="../../basics/algorithm_selection/">Algorithm Selection Guide</a></li><li><a class="tocitem" href="../../basics/common_solver_opts/">Common Solver Options (Keyword Arguments for Solve)</a></li><li><a class="tocitem" href="../../basics/OperatorAssumptions/">Linear Solve Operator Assumptions</a></li><li><a class="tocitem" href="../../basics/Preconditioners/">Preconditioners</a></li><li><a class="tocitem" href="../../basics/FAQ/">Frequently Asked Questions</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../solvers/solvers/">Linear System Solvers</a></li></ul></li><li><span class="tocitem">Advanced</span><ul><li><a class="tocitem" href="../developing/">Developing New Linear Solvers</a></li><li><a class="tocitem" href="../custom/">Passing in a Custom Linear Solver</a></li><li class="is-active"><a class="tocitem" href>Internal API Documentation</a><ul class="internal"><li><a class="tocitem" href="#Abstract-Type-Hierarchy"><span>Abstract Type Hierarchy</span></a></li><li><a class="tocitem" href="#Core-Cache-System"><span>Core Cache System</span></a></li><li><a class="tocitem" href="#Algorithm-Selection"><span>Algorithm Selection</span></a></li><li><a class="tocitem" href="#Trait-Functions"><span>Trait Functions</span></a></li><li><a class="tocitem" href="#Utility-Functions"><span>Utility Functions</span></a></li><li><a class="tocitem" href="#Solve-Functions"><span>Solve Functions</span></a></li><li><a class="tocitem" href="#Preconditioner-Infrastructure"><span>Preconditioner Infrastructure</span></a></li><li><a class="tocitem" href="#Internal-Algorithm-Types"><span>Internal Algorithm Types</span></a></li><li><a class="tocitem" href="#Developer-Notes"><span>Developer Notes</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../release_notes/">Release Notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Advanced</a></li><li class="is-active"><a href>Internal API Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internal API Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/LinearSolve.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/LinearSolve.jl/blob/main/docs/src/advanced/internal_api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal-API-Documentation"><a class="docs-heading-anchor" href="#Internal-API-Documentation">Internal API Documentation</a><a id="Internal-API-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-API-Documentation" title="Permalink"></a></h1><p>This page documents LinearSolve.jl&#39;s internal API, which is useful for developers who want to understand the package&#39;s architecture, contribute to the codebase, or develop custom linear solver algorithms.</p><h2 id="Abstract-Type-Hierarchy"><a class="docs-heading-anchor" href="#Abstract-Type-Hierarchy">Abstract Type Hierarchy</a><a id="Abstract-Type-Hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Type-Hierarchy" title="Permalink"></a></h2><p>LinearSolve.jl uses a well-structured type hierarchy to organize different classes of linear solver algorithms:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.SciMLLinearSolveAlgorithm" href="#LinearSolve.SciMLLinearSolveAlgorithm"><code>LinearSolve.SciMLLinearSolveAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLLinearSolveAlgorithm &lt;: SciMLBase.AbstractLinearAlgorithm</code></pre><p>The root abstract type for all linear solver algorithms in LinearSolve.jl. All concrete linear solver implementations should inherit from one of the specialized subtypes rather than directly from this type.</p><p>This type integrates with the SciMLBase ecosystem, providing a consistent interface for linear algebra operations across the Julia scientific computing ecosystem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/LinearSolve.jl#L71-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.AbstractFactorization" href="#LinearSolve.AbstractFactorization"><code>LinearSolve.AbstractFactorization</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractFactorization &lt;: SciMLLinearSolveAlgorithm</code></pre><p>Abstract type for linear solvers that work by computing a matrix factorization. These algorithms typically decompose the matrix <code>A</code> into a product of simpler matrices (e.g., <code>A = LU</code>, <code>A = QR</code>, <code>A = LDL&#39;</code>) and then solve the system using forward/backward substitution.</p><p><strong>Characteristics</strong></p><ul><li>Requires concrete matrix representation (<code>needs_concrete_A() = true</code>)</li><li>Typically efficient for multiple solves with the same matrix</li><li>Generally provides high accuracy for well-conditioned problems</li><li>Memory requirements depend on the specific factorization type</li></ul><p><strong>Subtypes</strong></p><ul><li><code>AbstractDenseFactorization</code>: For dense matrix factorizations</li><li><code>AbstractSparseFactorization</code>: For sparse matrix factorizations</li></ul><p><strong>Examples of concrete subtypes</strong></p><ul><li><code>LUFactorization</code>, <code>QRFactorization</code>, <code>CholeskyFactorization</code></li><li><code>UMFPACKFactorization</code>, <code>KLUFactorization</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/LinearSolve.jl#L84-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.AbstractDenseFactorization" href="#LinearSolve.AbstractDenseFactorization"><code>LinearSolve.AbstractDenseFactorization</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractDenseFactorization &lt;: AbstractFactorization</code></pre><p>Abstract type for factorization-based linear solvers optimized for dense matrices. These algorithms assume the matrix has no particular sparsity structure and use dense linear algebra routines (typically from BLAS/LAPACK) for optimal performance.</p><p><strong>Characteristics</strong></p><ul><li>Optimized for matrices with few zeros or no sparsity structure</li><li>Leverage highly optimized BLAS/LAPACK routines when available</li><li>Generally provide excellent performance for moderately-sized dense problems</li><li>Memory usage scales as O(n²) with matrix size</li></ul><p><strong>Examples of concrete subtypes</strong></p><ul><li><code>LUFactorization</code>: Dense LU with partial pivoting (via LAPACK)</li><li><code>QRFactorization</code>: Dense QR factorization for overdetermined systems</li><li><code>CholeskyFactorization</code>: Dense Cholesky for symmetric positive definite matrices</li><li><code>BunchKaufmanFactorization</code>: For symmetric indefinite matrices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/LinearSolve.jl#L134-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.AbstractSparseFactorization" href="#LinearSolve.AbstractSparseFactorization"><code>LinearSolve.AbstractSparseFactorization</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractSparseFactorization &lt;: AbstractFactorization</code></pre><p>Abstract type for factorization-based linear solvers optimized for sparse matrices. These algorithms take advantage of sparsity patterns to reduce memory usage and computational cost compared to dense factorizations.</p><p><strong>Characteristics</strong></p><ul><li>Optimized for matrices with many zero entries</li><li>Often use specialized pivoting strategies to preserve sparsity</li><li>May reorder rows/columns to minimize fill-in during factorization</li><li>Typically more memory-efficient than dense methods for sparse problems</li></ul><p><strong>Examples of concrete subtypes</strong></p><ul><li><code>UMFPACKFactorization</code>: General sparse LU with partial pivoting</li><li><code>KLUFactorization</code>: Sparse LU optimized for circuit simulation</li><li><code>CHOLMODFactorization</code>: Sparse Cholesky for positive definite systems</li><li><code>SparspakFactorization</code>: Envelope/profile method for sparse systems</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/LinearSolve.jl#L111-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.AbstractKrylovSubspaceMethod" href="#LinearSolve.AbstractKrylovSubspaceMethod"><code>LinearSolve.AbstractKrylovSubspaceMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractKrylovSubspaceMethod &lt;: SciMLLinearSolveAlgorithm</code></pre><p>Abstract type for iterative linear solvers based on Krylov subspace methods. These algorithms solve linear systems by iteratively building an approximation from a sequence of Krylov subspaces, without requiring explicit matrix factorization.</p><p><strong>Characteristics</strong></p><ul><li>Does not require concrete matrix representation (<code>needs_concrete_A() = false</code>)</li><li>Only needs matrix-vector products <code>A*v</code> (can work with operators/functions)</li><li>Memory usage typically O(n) or O(kn) where k &lt;&lt; n</li><li>Convergence depends on matrix properties (condition number, eigenvalue distribution)</li><li>Often benefits significantly from preconditioning</li></ul><p><strong>Advantages</strong></p><ul><li>Low memory requirements for large sparse systems</li><li>Can handle matrix-free operators (functions that compute <code>A*v</code>)</li><li>Often the only feasible approach for very large systems</li><li>Can exploit matrix structure through specialized operators</li></ul><p><strong>Examples of concrete subtypes</strong></p><ul><li><code>GMRESIteration</code>: Generalized Minimal Residual method</li><li><code>CGIteration</code>: Conjugate Gradient (for symmetric positive definite systems)</li><li><code>BiCGStabLIteration</code>: Bi-Conjugate Gradient Stabilized</li><li>Wrapped external iterative solvers (KrylovKit.jl, IterativeSolvers.jl)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/LinearSolve.jl#L157-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.AbstractSolveFunction" href="#LinearSolve.AbstractSolveFunction"><code>LinearSolve.AbstractSolveFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractSolveFunction &lt;: SciMLLinearSolveAlgorithm</code></pre><p>Abstract type for linear solvers that wrap custom solving functions or provide direct interfaces to specific solve methods. These provide flexibility for integrating custom algorithms or simple solve strategies.</p><p><strong>Characteristics</strong></p><ul><li>Does not require concrete matrix representation (<code>needs_concrete_A() = false</code>)</li><li>Provides maximum flexibility for custom solving strategies</li><li>Can wrap external solver libraries or implement specialized algorithms</li><li>Performance and stability depend entirely on the wrapped implementation</li></ul><p><strong>Examples of concrete subtypes</strong></p><ul><li><code>LinearSolveFunction</code>: Wraps arbitrary user-defined solve functions</li><li><code>DirectLdiv!</code>: Direct application of the <code>\</code> operator</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/LinearSolve.jl#L188-L206">source</a></section></article><h2 id="Core-Cache-System"><a class="docs-heading-anchor" href="#Core-Cache-System">Core Cache System</a><a id="Core-Cache-System-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Cache-System" title="Permalink"></a></h2><p>The caching system is central to LinearSolve.jl&#39;s performance and functionality:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.LinearCache" href="#LinearSolve.LinearCache"><code>LinearSolve.LinearCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearCache{TA, Tb, Tu, Tp, Talg, Tc, Tl, Tr, Ttol, issq, S}</code></pre><p>The core cache structure used by LinearSolve for storing and managing the state of linear solver computations. This mutable struct acts as the primary interface for iterative  solving and caching of factorizations and intermediate results.</p><p><strong>Fields</strong></p><ul><li><code>A::TA</code>: The matrix operator of the linear system.</li><li><code>b::Tb</code>: The right-hand side vector of the linear system.</li><li><code>u::Tu</code>: The solution vector (preallocated storage for the result).</li><li><code>p::Tp</code>: Parameters passed to the linear solver algorithm.</li><li><code>alg::Talg</code>: The linear solver algorithm instance.</li><li><code>cacheval::Tc</code>: Algorithm-specific cache storage for factorizations and intermediate computations.</li><li><code>isfresh::Bool</code>: Cache validity flag for the matrix <code>A</code>. <code>false</code> means <code>cacheval</code> is up-to-date  with respect to <code>A</code>, <code>true</code> means <code>cacheval</code> needs to be updated.</li><li><code>precsisfresh::Bool</code>: Cache validity flag for preconditioners. <code>false</code> means <code>Pl</code> and <code>Pr</code>  are up-to-date with respect to <code>A</code>, <code>true</code> means they need to be updated.</li><li><code>Pl::Tl</code>: Left preconditioner operator.</li><li><code>Pr::Tr</code>: Right preconditioner operator.</li><li><code>abstol::Ttol</code>: Absolute tolerance for iterative solvers.</li><li><code>reltol::Ttol</code>: Relative tolerance for iterative solvers.</li><li><code>maxiters::Int</code>: Maximum number of iterations for iterative solvers.</li><li><code>verbose::Bool</code>: Whether to print verbose output during solving.</li><li><code>assumptions::OperatorAssumptions{issq}</code>: Assumptions about the operator properties.</li><li><code>sensealg::S</code>: Sensitivity analysis algorithm for automatic differentiation.</li></ul><p><strong>Usage</strong></p><p>The <code>LinearCache</code> is typically created via <code>init(::LinearProblem, ::SciMLLinearSolveAlgorithm)</code>  and then used with <code>solve!(cache)</code> for efficient repeated solves with the same matrix structure but potentially different right-hand sides or parameter values.</p><p><strong>Cache Management</strong></p><p>The cache automatically tracks when matrix <code>A</code> or parameters <code>p</code> change by setting the  appropriate freshness flags. When <code>solve!</code> is called, stale cache entries are automatically recomputed as needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/common.jl#L68-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.init_cacheval" href="#LinearSolve.init_cacheval"><code>LinearSolve.init_cacheval</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_cacheval(alg::SciMLLinearSolveAlgorithm, args...)</code></pre><p>Initialize algorithm-specific cache values for the given linear solver algorithm. This function returns <code>nothing</code> by default and is intended to be overloaded by  specific algorithm implementations that need to store intermediate computations or factorizations.</p><p><strong>Arguments</strong></p><ul><li><code>alg</code>: The linear solver algorithm instance</li><li><code>args...</code>: Additional arguments passed to the cache initialization</li></ul><p><strong>Returns</strong></p><p>Algorithm-specific cache value or <code>nothing</code> for algorithms that don&#39;t require caching.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/common.jl#L149-L163">source</a></section><section><div><p>cache.cacheval = NamedTuple(LUFactorization = cache of LUFactorization, ...)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/default.jl#L463-L465">source</a></section></article><h2 id="Algorithm-Selection"><a class="docs-heading-anchor" href="#Algorithm-Selection">Algorithm Selection</a><a id="Algorithm-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-Selection" title="Permalink"></a></h2><p>The automatic algorithm selection is one of LinearSolve.jl&#39;s key features:</p><div class="admonition is-warning" id="Missing-docstring.-371191df94334961"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-371191df94334961" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>LinearSolve.defaultalg</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.get_tuned_algorithm" href="#LinearSolve.get_tuned_algorithm"><code>LinearSolve.get_tuned_algorithm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_tuned_algorithm(::Type{eltype_A}, ::Type{eltype_b}, matrix_size) where {eltype_A, eltype_b}</code></pre><p>Get the tuned algorithm preference for the given element type and matrix size. Returns <code>nothing</code> if no preference exists. Uses preloaded constants for efficiency. Fast path when no preferences are set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/default.jl#L239-L245">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.is_algorithm_available" href="#LinearSolve.is_algorithm_available"><code>LinearSolve.is_algorithm_available</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_algorithm_available(alg::DefaultAlgorithmChoice.T)</code></pre><p>Check if the given algorithm is currently available (extensions loaded, etc.).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/LinearSolve.jl#L310-L314">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.show_algorithm_choices" href="#LinearSolve.show_algorithm_choices"><code>LinearSolve.show_algorithm_choices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">show_algorithm_choices()</code></pre><p>Display what algorithm choices are actually made by the default solver for  representative matrix sizes. Shows current preferences and system information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/preferences.jl#L222-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.make_preferences_dynamic!" href="#LinearSolve.make_preferences_dynamic!"><code>LinearSolve.make_preferences_dynamic!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">make_preferences_dynamic!()</code></pre><p><strong>Internal function for testing only.</strong> Makes preferences dynamic by redefining get<em>tuned</em>algorithm to check preferences at runtime instead of using compile-time constants. This allows tests to verify that the preference system works correctly.</p><div class="admonition is-warning" id="Testing-Only-e86b6fa55718c3d2"><header class="admonition-header">Testing Only<a class="admonition-anchor" href="#Testing-Only-e86b6fa55718c3d2" title="Permalink"></a></header><div class="admonition-body"><p>This function is only intended for internal testing purposes. It modifies global state and should never be used in production code.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/preferences.jl#L147-L157">source</a></section></article><h3 id="Preference-System-Architecture"><a class="docs-heading-anchor" href="#Preference-System-Architecture">Preference System Architecture</a><a id="Preference-System-Architecture-1"></a><a class="docs-heading-anchor-permalink" href="#Preference-System-Architecture" title="Permalink"></a></h3><p>The dual preference system provides intelligent algorithm selection with comprehensive fallbacks:</p><h4 id="**Core-Functions**"><a class="docs-heading-anchor" href="#**Core-Functions**"><strong>Core Functions</strong></a><a id="**Core-Functions**-1"></a><a class="docs-heading-anchor-permalink" href="#**Core-Functions**" title="Permalink"></a></h4><ul><li><strong><code>get_tuned_algorithm</code></strong>: Retrieves tuned algorithm preferences based on matrix size and element type</li><li><strong><code>is_algorithm_available</code></strong>: Checks if a specific algorithm is currently available (extensions loaded)  </li><li><strong><code>show_algorithm_choices</code></strong>: Analysis function displaying algorithm choices for all element types</li><li><strong><code>make_preferences_dynamic!</code></strong>: Testing function that enables runtime preference checking</li></ul><h4 id="**Size-Categorization**"><a class="docs-heading-anchor" href="#**Size-Categorization**"><strong>Size Categorization</strong></a><a id="**Size-Categorization**-1"></a><a class="docs-heading-anchor-permalink" href="#**Size-Categorization**" title="Permalink"></a></h4><p>The system categorizes matrix sizes to match LinearSolveAutotune benchmarking:</p><ul><li><strong>tiny</strong>: ≤20 elements (matrices ≤10 always override to GenericLU)</li><li><strong>small</strong>: 21-100 elements  </li><li><strong>medium</strong>: 101-300 elements</li><li><strong>large</strong>: 301-1000 elements</li><li><strong>big</strong>: &gt;1000 elements</li></ul><h4 id="**Dual-Preference-Structure**"><a class="docs-heading-anchor" href="#**Dual-Preference-Structure**"><strong>Dual Preference Structure</strong></a><a id="**Dual-Preference-Structure**-1"></a><a class="docs-heading-anchor-permalink" href="#**Dual-Preference-Structure**" title="Permalink"></a></h4><p>For each category and element type (Float32, Float64, ComplexF32, ComplexF64):</p><ul><li><code>best_algorithm_{type}_{size}</code>: Overall fastest algorithm from autotune</li><li><code>best_always_loaded_{type}_{size}</code>: Fastest always-available algorithm (fallback)</li></ul><h4 id="**Preference-File-Organization**"><a class="docs-heading-anchor" href="#**Preference-File-Organization**"><strong>Preference File Organization</strong></a><a id="**Preference-File-Organization**-1"></a><a class="docs-heading-anchor-permalink" href="#**Preference-File-Organization**" title="Permalink"></a></h4><p>All preference-related functionality is consolidated in <code>src/preferences.jl</code>:</p><p><strong>Compile-Time Constants</strong>:</p><ul><li><code>AUTOTUNE_PREFS</code>: Preference structure loaded at package import</li><li><code>AUTOTUNE_PREFS_SET</code>: Fast path check for whether any preferences are set</li><li><code>_string_to_algorithm_choice</code>: Mapping from preference strings to algorithm enums</li></ul><p><strong>Runtime Functions</strong>:</p><ul><li><code>_get_tuned_algorithm_runtime</code>: Dynamic preference checking for testing</li><li><code>_choose_available_algorithm</code>: Algorithm availability and fallback logic</li><li><code>show_algorithm_choices</code>: Comprehensive analysis and display function</li></ul><p><strong>Testing Infrastructure</strong>:</p><ul><li><code>make_preferences_dynamic!</code>: Eval-based function redefinition for testing</li><li>Enables runtime preference verification without affecting production performance</li></ul><h4 id="**Testing-Mode-Operation**"><a class="docs-heading-anchor" href="#**Testing-Mode-Operation**"><strong>Testing Mode Operation</strong></a><a id="**Testing-Mode-Operation**-1"></a><a class="docs-heading-anchor-permalink" href="#**Testing-Mode-Operation**" title="Permalink"></a></h4><p>The testing system uses an elegant eval-based approach:</p><pre><code class="language-julia hljs"># Production: Uses compile-time constants (maximum performance)
get_tuned_algorithm(Float64, Float64, 200)  # → Uses AUTOTUNE_PREFS constants

# Testing: Redefines function to use runtime checking
make_preferences_dynamic!()
get_tuned_algorithm(Float64, Float64, 200)  # → Uses runtime preference loading</code></pre><p>This approach maintains type stability and inference while enabling comprehensive testing.</p><h4 id="**Algorithm-Support-Scope**"><a class="docs-heading-anchor" href="#**Algorithm-Support-Scope**"><strong>Algorithm Support Scope</strong></a><a id="**Algorithm-Support-Scope**-1"></a><a class="docs-heading-anchor-permalink" href="#**Algorithm-Support-Scope**" title="Permalink"></a></h4><p>The preference system focuses exclusively on LU algorithms for dense matrices:</p><p><strong>Supported LU Algorithms</strong>:</p><ul><li><code>LUFactorization</code>, <code>GenericLUFactorization</code>, <code>RFLUFactorization</code></li><li><code>MKLLUFactorization</code>, <code>AppleAccelerateLUFactorization</code></li><li><code>SimpleLUFactorization</code>, <code>FastLUFactorization</code> (both map to LU)</li><li>GPU LU variants (CUDA, Metal, AMDGPU - all map to LU)</li></ul><p><strong>Non-LU algorithms</strong> (QR, Cholesky, SVD, etc.) are not included in the preference system as they serve different use cases and are not typically the focus of dense matrix autotune optimization.</p><h2 id="Trait-Functions"><a class="docs-heading-anchor" href="#Trait-Functions">Trait Functions</a><a id="Trait-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Trait-Functions" title="Permalink"></a></h2><p>These trait functions help determine algorithm capabilities and requirements:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.needs_concrete_A" href="#LinearSolve.needs_concrete_A"><code>LinearSolve.needs_concrete_A</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">needs_concrete_A(alg) -&gt; Bool</code></pre><p>Trait function that determines whether a linear solver algorithm requires a concrete matrix representation or can work with abstract operators.</p><p><strong>Arguments</strong></p><ul><li><code>alg</code>: A linear solver algorithm instance</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code>: Algorithm requires a concrete matrix (e.g., for factorization)</li><li><code>false</code>: Algorithm can work with abstract operators (e.g., matrix-free methods)</li></ul><p><strong>Usage</strong></p><p>This trait is used internally by LinearSolve.jl to optimize algorithm dispatch and determine when matrix operators need to be converted to concrete arrays.</p><p><strong>Algorithm-Specific Behavior</strong></p><ul><li><code>AbstractFactorization</code>: <code>true</code> (needs explicit matrix entries for factorization)</li><li><code>AbstractKrylovSubspaceMethod</code>: <code>false</code> (only needs matrix-vector products)</li><li><code>AbstractSolveFunction</code>: <code>false</code> (depends on the wrapped function&#39;s requirements)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">needs_concrete_A(LUFactorization())  # true
needs_concrete_A(GMRESIteration())   # false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/LinearSolve.jl#L211-L243">source</a></section></article><h2 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h2><p>Various utility functions support the core functionality:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.default_tol" href="#LinearSolve.default_tol"><code>LinearSolve.default_tol</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">default_tol(T)</code></pre><p>Compute the default tolerance for iterative linear solvers based on the element type. The tolerance is typically set as the square root of the machine epsilon for the  given floating point type, ensuring numerical accuracy appropriate for that precision.</p><p><strong>Arguments</strong></p><ul><li><code>T</code>: The element type of the linear system</li></ul><p><strong>Returns</strong></p><ul><li>For floating point types: <code>√(eps(T))</code></li><li>For exact types (Rational, Integer): <code>0</code> (exact arithmetic)</li><li>For Any type: <code>0</code> (conservative default)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/common.jl#L170-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.default_alias_A" href="#LinearSolve.default_alias_A"><code>LinearSolve.default_alias_A</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">default_alias_A(alg, A, b) -&gt; Bool</code></pre><p>Determine the default aliasing behavior for the matrix <code>A</code> given the algorithm type. Aliasing allows the algorithm to modify the original matrix in-place for efficiency, but this may not be desirable or safe for all algorithm types.</p><p><strong>Arguments</strong></p><ul><li><code>alg</code>: The linear solver algorithm</li><li><code>A</code>: The matrix operator  </li><li><code>b</code>: The right-hand side vector</li></ul><p><strong>Returns</strong></p><ul><li><code>false</code>: Safe default, algorithm will not modify the original matrix <code>A</code></li><li><code>true</code>: Algorithm may modify <code>A</code> in-place for efficiency</li></ul><p><strong>Algorithm-Specific Behavior</strong></p><ul><li>Dense factorizations: <code>false</code> (destructive, need to preserve original)</li><li>Krylov methods: <code>true</code> (non-destructive, safe to alias)</li><li>Sparse factorizations: <code>true</code> (typically preserve sparsity structure)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/common.jl#L191-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.default_alias_b" href="#LinearSolve.default_alias_b"><code>LinearSolve.default_alias_b</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">default_alias_b(alg, A, b) -&gt; Bool</code></pre><p>Determine the default aliasing behavior for the right-hand side vector <code>b</code> given the  algorithm type. Similar to <code>default_alias_A</code> but for the RHS vector.</p><p><strong>Returns</strong></p><ul><li><code>false</code>: Safe default, algorithm will not modify the original vector <code>b</code></li><li><code>true</code>: Algorithm may modify <code>b</code> in-place for efficiency</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/common.jl#L214-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.__init_u0_from_Ab" href="#LinearSolve.__init_u0_from_Ab"><code>LinearSolve.__init_u0_from_Ab</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">__init_u0_from_Ab(A, b)</code></pre><p>Initialize the solution vector <code>u0</code> with appropriate size and type based on the  matrix <code>A</code> and right-hand side <code>b</code>. The solution vector is allocated with the  same element type as <code>b</code> and sized to match the number of columns in <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: The matrix operator (determines solution vector size)</li><li><code>b</code>: The right-hand side vector (determines element type)</li></ul><p><strong>Returns</strong></p><p>A zero-initialized vector of size <code>(size(A, 2),)</code> with element type matching <code>b</code>.</p><p><strong>Specializations</strong></p><ul><li>For static matrices (<code>SMatrix</code>): Returns a static vector (<code>SVector</code>)</li><li>For regular matrices: Returns a similar vector to <code>b</code> with appropriate size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/common.jl#L235-L252">source</a></section></article><h2 id="Solve-Functions"><a class="docs-heading-anchor" href="#Solve-Functions">Solve Functions</a><a id="Solve-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-Functions" title="Permalink"></a></h2><p>For custom solving strategies:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.LinearSolveFunction" href="#LinearSolve.LinearSolveFunction"><code>LinearSolve.LinearSolveFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearSolveFunction{F} &lt;: AbstractSolveFunction</code></pre><p>A flexible wrapper that allows using custom functions as linear solver algorithms. This provides a way to integrate user-defined solving strategies into the LinearSolve.jl framework while maintaining compatibility with the caching and interface systems.</p><p><strong>Fields</strong></p><ul><li><code>solve_func::F</code>: A callable that implements the custom linear solving logic</li></ul><p><strong>Function Signature</strong></p><p>The wrapped function should have the signature:</p><pre><code class="language-julia hljs">solve_func(A, b, u, p, isfresh, Pl, Pr, cacheval; kwargs...)</code></pre><p><strong>Arguments to wrapped function</strong></p><ul><li><code>A</code>: The matrix operator of the linear system  </li><li><code>b</code>: The right-hand side vector</li><li><code>u</code>: Pre-allocated solution vector (can be used as working space)</li><li><code>p</code>: Parameters passed to the solver</li><li><code>isfresh</code>: Boolean indicating if the matrix <code>A</code> has changed since last solve</li><li><code>Pl</code>: Left preconditioner operator</li><li><code>Pr</code>: Right preconditioner operator  </li><li><code>cacheval</code>: Algorithm-specific cache storage</li><li><code>kwargs...</code>: Additional keyword arguments</li></ul><p><strong>Returns</strong></p><p>The wrapped function should return a solution vector.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">function my_custom_solver(A, b, u, p, isfresh, Pl, Pr, cacheval; kwargs...)
    # Custom solving logic here
    return A \ b  # Simple example
end

alg = LinearSolveFunction(my_custom_solver)
sol = solve(prob, alg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/solve_function.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.DirectLdiv!" href="#LinearSolve.DirectLdiv!"><code>LinearSolve.DirectLdiv!</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DirectLdiv! &lt;: AbstractSolveFunction</code></pre><p>A simple linear solver that directly applies the left-division operator (<code>\</code>)  to solve the linear system. This algorithm calls <code>ldiv!(u, A, b)</code> which computes <code>u = A \ b</code> in-place.</p><p><strong>Usage</strong></p><pre><code class="language-julia hljs">alg = DirectLdiv!()
sol = solve(prob, alg)</code></pre><p><strong>Notes</strong></p><ul><li>This is essentially a direct wrapper around Julia&#39;s built-in <code>ldiv!</code> function</li><li>Suitable for cases where the matrix <code>A</code> has a natural inverse or factorization</li><li>Performance depends on the specific matrix type and its <code>ldiv!</code> implementation</li><li>No preconditioners or advanced numerical techniques are applied</li><li>Best used for small to medium problems or when <code>A</code> has special structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/solve_function.jl#L57-L78">source</a></section></article><h2 id="Preconditioner-Infrastructure"><a class="docs-heading-anchor" href="#Preconditioner-Infrastructure">Preconditioner Infrastructure</a><a id="Preconditioner-Infrastructure-1"></a><a class="docs-heading-anchor-permalink" href="#Preconditioner-Infrastructure" title="Permalink"></a></h2><p>The preconditioner system allows for flexible preconditioning strategies:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.ComposePreconditioner" href="#LinearSolve.ComposePreconditioner"><code>LinearSolve.ComposePreconditioner</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ComposePreconditioner{Ti, To}</code></pre><p>A preconditioner that composes two preconditioners by applying them sequentially. The inner preconditioner is applied first, followed by the outer preconditioner. This allows for building complex preconditioning strategies by combining simpler ones.</p><p><strong>Fields</strong></p><ul><li><code>inner::Ti</code>: The inner (first) preconditioner to apply</li><li><code>outer::To</code>: The outer (second) preconditioner to apply</li></ul><p><strong>Usage</strong></p><pre><code class="language-julia hljs"># Compose a diagonal preconditioner with an ILU preconditioner
inner_prec = DiagonalPreconditioner(diag(A))
outer_prec = ILUFactorization()  
composed = ComposePreconditioner(inner_prec, outer_prec)</code></pre><p>The composed preconditioner applies: <code>outer(inner(x))</code> for any vector <code>x</code>.</p><p><strong>Mathematical Interpretation</strong></p><p>For a linear system <code>Ax = b</code>, if <code>P₁</code> is the inner and <code>P₂</code> is the outer preconditioner, then the composed preconditioner effectively applies <code>P₂P₁</code> as the combined preconditioner.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/preconditioners.jl#L3-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.InvPreconditioner" href="#LinearSolve.InvPreconditioner"><code>LinearSolve.InvPreconditioner</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InvPreconditioner{T}</code></pre><p>A preconditioner wrapper that treats a matrix or operator as if it represents the inverse of the actual preconditioner. Instead of solving <code>Px = y</code>, it  computes <code>P*y</code> where <code>P</code> is stored as the &quot;inverse&quot; preconditioner matrix.</p><p><strong>Fields</strong></p><ul><li><code>P::T</code>: The stored preconditioner matrix/operator (representing <code>P⁻¹</code>)</li></ul><p><strong>Usage</strong></p><p>This is useful when you have a matrix that approximates the inverse of your desired preconditioner. For example, if you have computed an approximate  inverse matrix <code>Ainv ≈ A⁻¹</code>, you can use:</p><pre><code class="language-julia hljs">prec = InvPreconditioner(Ainv)</code></pre><p><strong>Mathematical Interpretation</strong></p><p>For a linear system <code>Ax = b</code> with preconditioner <code>M</code>, normally we solve <code>M⁻¹Ax = M⁻¹b</code>. With <code>InvPreconditioner</code>, the stored matrix <code>P</code> represents <code>M⁻¹</code> directly, so applying the preconditioner becomes a matrix-vector multiplication rather than a linear solve.</p><p><strong>Methods</strong></p><ul><li><code>ldiv!(A::InvPreconditioner, x)</code>: Computes <code>x ← P*x</code> (in-place)</li><li><code>ldiv!(y, A::InvPreconditioner, x)</code>: Computes <code>y ← P*x</code>  </li><li><code>mul!(y, A::InvPreconditioner, x)</code>: Computes <code>y ← P⁻¹*x</code> (inverse operation)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/preconditioners.jl#L51-L83">source</a></section></article><h2 id="Internal-Algorithm-Types"><a class="docs-heading-anchor" href="#Internal-Algorithm-Types">Internal Algorithm Types</a><a id="Internal-Algorithm-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Algorithm-Types" title="Permalink"></a></h2><p>These are internal algorithm implementations:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.SimpleLUFactorization" href="#LinearSolve.SimpleLUFactorization"><code>LinearSolve.SimpleLUFactorization</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimpleLUFactorization(pivot::Bool = true)</code></pre><p>A pure Julia LU factorization implementation without BLAS dependencies. This solver is optimized for small matrices and situations where BLAS  is not available or desirable.</p><p><strong>Constructor Arguments</strong></p><ul><li><code>pivot::Bool = true</code>: Whether to perform partial pivoting for numerical stability. Set to <code>false</code> for slightly better performance at the cost of stability.</li></ul><p><strong>Features</strong></p><ul><li>Pure Julia implementation (no BLAS dependencies)</li><li>Partial pivoting support for numerical stability</li><li>In-place matrix modification for memory efficiency  </li><li>Fast for small matrices (typically &lt; 100×100)</li><li>Educational value for understanding LU factorization</li></ul><p><strong>Performance Characteristics</strong></p><ul><li>Optimal for small dense matrices</li><li>No overhead from BLAS calls</li><li>Linear scaling with problem size (O(n³) operations)</li><li>Memory efficient due to in-place operations</li></ul><p><strong>Use Cases</strong></p><ul><li>Small matrices where BLAS overhead is significant</li><li>Systems without optimized BLAS libraries</li><li>Educational and prototyping purposes</li><li>Embedded systems with memory constraints</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Stable version with pivoting (default)
alg1 = SimpleLUFactorization()
# Faster version without pivoting
alg2 = SimpleLUFactorization(false)

prob = LinearProblem(A, b)
sol = solve(prob, alg1)</code></pre><p><strong>Notes</strong></p><p>For larger matrices (&gt; 100×100), consider using BLAS-based factorizations  like <code>LUFactorization()</code> for better performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/simplelu.jl#L155-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearSolve.LUSolver" href="#LinearSolve.LUSolver"><code>LinearSolve.LUSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LUSolver{T}</code></pre><p>A mutable workspace for performing LU factorization and solving linear systems. This struct maintains all necessary arrays and state information for the  factorization and solve phases, allowing for efficient reuse when solving multiple systems with the same matrix structure.</p><p><strong>Fields</strong></p><ul><li><code>n::Int</code>: Dimension of the square matrix</li><li><code>A::Matrix{T}</code>: Working copy of the matrix to be factorized (modified in-place)</li><li><code>b::Vector{T}</code>: Right-hand side vector storage</li><li><code>x::Vector{T}</code>: Solution vector storage  </li><li><code>pivots::Vector{Int}</code>: Pivot indices from the factorization</li><li><code>perms::Vector{Int}</code>: Permutation vector tracking row exchanges</li><li><code>info::Int</code>: Status information (0 = success, &gt;0 indicates singularity)</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">LUSolver{T}(n)  # Create solver for n×n matrix with element type T</code></pre><p><strong>Usage</strong></p><p>The solver is typically created from a matrix using the convenience constructors:</p><pre><code class="language-julia hljs">solver = LUSolver(A)        # From matrix A
solver = LUSolver(A, b)     # From matrix A and RHS b</code></pre><p>Then factorized and solved:</p><pre><code class="language-julia hljs">simplelu_factorize!(solver)    # Perform LU factorization
simplelu_solve!(solver)        # Solve for the stored RHS</code></pre><p><strong>Notes</strong></p><p>This is a pure Julia implementation primarily for educational purposes and small matrices. For production use, prefer optimized LAPACK-based factorizations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/LinearSolve.jl/blob/e86eb887c02f0dfa376f99226670d2b4283a625f/src/simplelu.jl#L3-L41">source</a></section></article><h2 id="Developer-Notes"><a class="docs-heading-anchor" href="#Developer-Notes">Developer Notes</a><a id="Developer-Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Developer-Notes" title="Permalink"></a></h2><h3 id="Adding-New-Algorithms"><a class="docs-heading-anchor" href="#Adding-New-Algorithms">Adding New Algorithms</a><a id="Adding-New-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-New-Algorithms" title="Permalink"></a></h3><p>When adding a new linear solver algorithm to LinearSolve.jl:</p><ol><li><strong>Choose the appropriate abstract type</strong>: Inherit from the most specific abstract type that fits your algorithm</li><li><strong>Implement required methods</strong>: At minimum, implement <code>solve!</code> and possibly <code>init_cacheval</code></li><li><strong>Consider trait functions</strong>: Override trait functions like <code>needs_concrete_A</code> if needed</li><li><strong>Document thoroughly</strong>: Add comprehensive docstrings following the patterns shown here</li></ol><h3 id="Performance-Considerations"><a class="docs-heading-anchor" href="#Performance-Considerations">Performance Considerations</a><a id="Performance-Considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Considerations" title="Permalink"></a></h3><ul><li>The <code>LinearCache</code> system is designed for efficient repeated solves</li><li>Use <code>cache.isfresh</code> to avoid redundant computations when the matrix hasn&#39;t changed</li><li>Consider implementing specialized <code>init_cacheval</code> for algorithms that need setup</li><li>Leverage trait functions to optimize dispatch and memory usage</li></ul><h3 id="Testing-Guidelines"><a class="docs-heading-anchor" href="#Testing-Guidelines">Testing Guidelines</a><a id="Testing-Guidelines-1"></a><a class="docs-heading-anchor-permalink" href="#Testing-Guidelines" title="Permalink"></a></h3><p>When adding new functionality:</p><ul><li>Test with various matrix types (dense, sparse, GPU arrays)</li><li>Verify caching behavior works correctly</li><li>Ensure trait functions return appropriate values</li><li>Test integration with the automatic algorithm selection system</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../custom/">« Passing in a Custom Linear Solver</a><a class="docs-footer-nextpage" href="../../release_notes/">Release Notes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 1 September 2025 18:24">Monday 1 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
